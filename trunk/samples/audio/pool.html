<!--
Copyright 2009, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
    * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>
Pool
</title>
<script type="text/javascript" src="o3djs/base.js"></script>
<script type="text/javascript">
o3djs.require('o3djs.util');
o3djs.require('o3djs.math');
o3djs.require('o3djs.rendergraph');
o3djs.require('o3djs.primitives');
o3djs.require('o3djs.quaternions');
o3djs.require('o3djs.effect');
o3djs.require('o3djs.event');

// Debug flags
var SHADOWPOV = false;

// global variables
var g_o3dElement;
var g_client;
var g_o3d;
var g_math;
var g_quat;
var g_pack;
var g_viewInfo;
var g_clock = 0;
var g_shadowPassViewInfo;
var g_ballTransforms = [];
var g_centers = [];

var g_ballTextures = [];
var g_ballTextureSamplers = [];
var g_ballTextureSamplerParams = [];
var g_shadowOnParams = [];

var g_shadowSampler;
var g_shadowTexture;

var g_tableRoot;
var g_shadowRoot;
var g_hudRoot;

var g_physics;

var g_target = [0, 0, 0];
var g_light = [0, 0, 50];

var g_materials;
var g_solidMaterial;

var RENDER_TARGET_WIDTH = 512;
var RENDER_TARGET_HEIGHT = 512;

var g_table;

var pool = {};

var xaudio = 0;
var pingBuffer = 0;

function loadPing(url) {
  // Load asynchronously
  var request = xaudio.createAudioRequest(url, true);
  request.onload = function() { 
    pingBuffer = request.buffer;
  }

  request.send();
}

function loadSoftPing(url) {
  // Load asynchronously
  var request = xaudio.createAudioRequest(url, true);
  request.onload = function() { 
    softPingBuffer = request.buffer;
  }

  request.send();
}

function playSound(buffer, velocity, x, y) {
  var ping = xaudio.getVoice();

  if (ping) {
    // base volume on velocity
    var xx = velocity;
    if (xx > 1.0) xx = 1.0;
    if (xx < 0.0) xx = 0.0;
    var s = Math.sin(0.5 * xx * Math.PI);
    s = s*s;
    var gain = s;

    


    var isQuiet = (gain < 0.5);
    ping.buffer = buffer;
    
    ping.sendGain = gain < 0.25 ? 5.0*0.8 : 5.0*0.5;
    ping.mainGain = gain;
    
    // Randomize pitch          
    var r = Math.random();
    var cents = 600.0 * (r - 0.5);
    var rate = Math.pow(2.0, cents / 1200.0);
    ping.playbackPitch = rate;  // really rate (not pitch)
    
    // Adjust filter
    var value = 0.5 + 0.5 * xx;
    var noctaves = Math.log(22050.0 / 40.0) / Math.LN2;
    var v2 = Math.pow(2.0, noctaves * (value - 1.0));
    
    var sampleRate = 44100.0;
    var nyquist = sampleRate * 0.5;
    ping.effect.param1 = v2;
    ping.effect.param2 = 5.0; // resonance
    
    var azimuth = 0.5*Math.PI * (x - 200.0 /*250.0*/) / 150.0;
    if (azimuth < -0.5*Math.PI) azimuth = -0.5*Math.PI;
    if (azimuth > 0.5*Math.PI) azimuth = 0.5*Math.PI;
    
    var posX = 10.0 * Math.sin(azimuth);
    var posZ = 10.0 * Math.cos(azimuth);
    
    
    var elevation = -0.5*Math.PI * (y - 250.0) / 150.0;
    if (elevation < -0.5*Math.PI) elevation = -0.5*Math.PI;
    if (elevation > 0.5*Math.PI) elevation = 0.5*Math.PI;
    
    var scaleY = Math.sin(elevation);
    var scaleXZ = Math.cos(elevation);
    posX *= scaleXZ;
    posZ *= scaleXZ;
    var posY = scaleY * 10.0;
    
    ping.setPosition(posX, posY, isQuiet ? +posZ : -posZ);

    ping.play(0);
  }
  
}




pool.Ball = function() {
  this.mass = 1.0;
  this.angularInertia = 0.4;
  this.center = [0, 0, 0];
  this.velocity = [0, 0, 0];
  this.verticalAcceleration = 0;
  this.orientation = [0, 0, 0, 1];
  this.angularVelocity = [0, 0, 0];
  this.active = true;
  this.sunkInPocket = -1;
};

pool.Physics = function() {
  this.speedFactor = 0;
  this.maxSpeed = 1;

  this.balls = [];
  for (var i = 0; i < 16; ++i) {
    this.balls.push(new pool.Ball());
  }

  // The cue ball is slightly heavier
  // than the rest of the balls.
  // 6 ounces versus 5.5.
  this.balls[0].mass *= 6.0 / 5.5;
  this.balls[0].rotationalInertia *= 6.0 / 5.5;

  this.walls = [];
  this.collisions = [];
  this.wallCollisions = [];

  this.step = function() {
    for (var i = 0; i < 5; ++i) {
      this.ballsLoseEnergy();
      this.ballsImpactFloor();
      this.move(1);
      while (this.collide()) {
        this.move(-1);
        this.handleCollisions();
        this.move(1);
      }
    }
    this.sink();
    this.handleFalling();
    this.placeBalls();
  };

  this.move = function(timeStep) {
    for (var i = 0; i < 16; ++i) {
      var ball = this.balls[i];
      if (!ball.active)
        continue;
      var p = ball.center;
      var v = ball.velocity;
      p[0] += timeStep * v[0];
      p[1] += timeStep * v[1];
      p[2] += timeStep * v[2];
      ball.orientation = this.quat.normalize(this.quat.mul(
          vectorToQuaternion(this.math.mulScalarVector(
              timeStep, ball.angularVelocity)), ball.orientation));
      v[2] += ball.verticalAcceleration;
    }
  };

  this.impartSpeed = function(i, direction) {
    var ball = this.balls[i];
    ball.velocity[0] += direction[0] * this.maxSpeed * this.speedFactor;
    ball.velocity[1] += direction[1] * this.maxSpeed * this.speedFactor;
  };

  this.stopSlowBalls = function() {
    var epsilon = 0.0001;
    for (var i = 0; i < 16; ++i) {
      var ball = this.balls[i];
      if (!ball.active)
        continue;
      var v = ball.velocity;
      var w = ball.angularVelocity;
      if (this.math.length(v) < epsilon) {
        v[0] = 0;
        v[1] = 0;
        v[2] = 0;
      }
      if (this.math.length(w) < epsilon) {
        w[0] = 0;
        w[1] = 0;
        w[2] = 0;
      }
    }
  };

  this.someBallsMoving = function() {
    for (var i = 0; i < 16; ++i) {
      var ball = this.balls[i];
      if (!ball.active)
        continue;
      var v = ball.velocity;
      var w = ball.angularVelocity;
      if (v[0] != 0 || v[1] != 0 || v[2] != 0 ||
          w[0] != 0 || w[1] != 0 || w[2] != 0)
        return true;
    }
    return false;
  };

  this.sink = function() {
    for (var i = 0; i < 16; ++i) {
      var ball = this.balls[i];
      if (!ball.active)
        continue;
      var p = this.balls[i].center;
      for (var j = 0; j < this.pocketCenters.length; ++j) {
        var pocketCenter = this.pocketCenters[j];
        var dx = p[0] - pocketCenter[0];
        var dy = p[1] - pocketCenter[1];
        if (dx * dx + dy * dy <
            this.pocketRadius * this.pocketRadius) {
          ball.verticalAcceleration = -0.005;
          ball.sunkInPocket = j;
        }
      }
    }
  };

  this.handleFalling = function() {
    for (var i = 0; i < 16; ++i) {
      var ball = this.balls[i];
      if (!ball.active)
        continue;
      if (ball.sunkInPocket >= 0) {
        var p = ball.center;
        var z = p[2];
        var pocketCenter = this.pocketCenters[ball.sunkInPocket];
        var dx = p[0] - pocketCenter[0];
        var dy = p[1] - pocketCenter[1];

        // Once the ball is sunk, it must not escape the pocket.
        var norm = Math.sqrt(dx * dx + dy * dy);
        var maxNorm =
            this.pocketRadius - Math.sqrt(Math.max(0, 1 - (z + 1) * (z + 1)));
        if (norm > maxNorm) {
          p[0] = pocketCenter[0] + dx * maxNorm / norm;
          p[1] = pocketCenter[1] + dy * maxNorm / norm;
        }
      }
      if (ball.center[2] < -3) {
        var v = ball.velocity;
        var w = ball.angularVelocity;
        v[0] = 0;
        v[1] = 0;
        v[2] = 0;
        w[0] = 0;
        w[1] = 0;
        w[2] = 0;
        ball.verticalAcceleration = 0;
        ball.active = false;
      }
    }
  };

  this.collide = function() {
    this.collideBalls();
    this.collideWithWalls();
    return this.collisions.length != 0 || this.wallCollisions.length != 0;
  };

  this.collideBalls = function() {
    this.collisions = [];
    for (var i = 0; i < 16; ++i) {
      if (!this.balls[i].active)
        continue;
      var p1 = this.balls[i].center;
      for (var j = 0; j < i; ++j) {
        if (!this.balls[j].active)
          continue;
        var p2 = this.balls[j].center;

        var dx = p1[0] - p2[0];
        var dy = p1[1] - p2[1];

        if (dx * dx + dy * dy < 3.99) {
          this.collisions.push({i: i, j: j});
        }
      }
    }
  };

  this.initWalls = function() {
    var r = this.pocketRadius;
    var w = this.tableWidth;

    // Three walls connecting the points in this list get put around each
    // cushion.
    var path = [[0, -w / 2 + r, 0],
                [r, -w / 2 + 2 * r, 0],
                [r, w / 2 - 2 * r, 0],
                [0, w / 2 - r, 0]];

    var angles = [0, Math.PI/2, Math.PI, Math.PI, 3 * Math.PI / 2, 0];
    var translations = this.math.mulMatrixMatrix(
        [[-1, -1, 0], [0, -2, 0], [1, -1, 0], [1, 1, 0], [0, 2, 0], [-1, 1, 0]],
        [[w / 2, 0, 0], [0, w / 2, 0], [0, 0, 1]]);

    for (var i = 0; i < 6; ++i) {
      var newPath = [];
      for (var j = 0; j < path.length; ++j) {
        newPath.push(
            this.math.matrix4.transformPoint(this.math.matrix4.composition(
                this.math.matrix4.translation(translations[i]),
                this.math.matrix4.rotationZ(angles[i])), path[j]));
      }

      for (var j = 0; j < newPath.length - 1; ++j) {
        this.walls.push({p: [newPath[j][0], newPath[j][1]],
                         q: [newPath[j + 1][0], newPath[j + 1][1]]});
      }
    }

    for (var i = 0; i < this.walls.length; ++i) {
      var wall = this.walls[i];
      var tangent = this.math.normalize(this.math.subVector(wall.q, wall.p));
      wall.nx = tangent[1];
      wall.ny = -tangent[0];
      wall.k = wall.nx * wall.p[0] + wall.ny * wall.p[1];
      wall.a = wall.p[1] * wall.nx - wall.p[0] * wall.ny;
      wall.b = wall.q[1] * wall.nx - wall.q[0] * wall.ny;
    }
  };

  this.collideWithWalls = function() {
    this.wallCollisions = [];

    for (var i = 0; i < 16; ++i) {
      var ball = this.balls[i];
      if (!ball.active)
        continue;
      var p = ball.center;
      var x = p[0];
      var y = p[1];

      if (x > this.left && x < this.right && y > this.bottom && y < this.top) {
        continue;
      }

      for (var j = 0; j < this.walls.length; ++j) {
        var wall = this.walls[j];

        if (Math.abs(x * wall.nx + y * wall.ny - wall.k) < 1) {
          var t = y * wall.nx - x * wall.ny;
          if (t > wall.a && t < wall.b) {
            this.wallCollisions.push({i: i, x: wall.nx, y: wall.ny});
            break;
          } else {
            var dx = x - wall.p[0];
            var dy = y - wall.p[1];
            var normSquared = dx * dx + dy * dy;
            if (dx * dx + dy * dy < 1) {
              var norm = Math.sqrt(normSquared);
              this.wallCollisions.push(
                  {i: i, x: dx / norm, y: dy / norm});
              break;
            }
            var dx = x - wall.q[0];
            var dy = y - wall.q[1];
            var normSquared = dx * dx + dy * dy;
            if (normSquared < 1) {
              var norm = Math.sqrt(normSquared);
              this.wallCollisions.push(
                  {i: i, x: dx / norm, y: dy / norm});
              break;
            }
          }
        }
      }
    }
  };

  this.handleCollisions = function() {
    var l = this.wallCollisions.length;
    for (var i = 0; i < l; ++i) {
      var c = this.wallCollisions[i];
      var ball = this.balls[c.i];
      var v = ball.velocity;
      var w = ball.angularVelocity;
      var r1 = [-c.x, -c.y, 0];
      var r2 = [c.x, c.y, 0];

      // alert("x = " + c.x + " : y = " + c.y );



      var impulse = this.impulse(
          v, w, ball.mass, ball.angularInertia, r1,
          [0, 0, 0], [0, 0, 0], 1e100, 1e100, r2,
          r1, 0.99, 0.2, 0.1);

      this.applyImpulse(c.i, impulse, r1);

      playSound(softPingBuffer, 0.25, 0, 0);

    }

    var l = this.collisions.length;
    for (var i = 0; i < l; ++i) {
      var c = this.collisions[i];
      var bi = this.balls[c.i];
      var bj = this.balls[c.j];
      var vi = bi.velocity;
      var wi = bi.angularVelocity;
      var vj = bj.velocity;
      var wj = bj.angularVelocity;

      var ri = this.math.normalize(this.math.subVector(bj.center, bi.center));
      var rj = this.math.negativeVector(ri);

      var impulse = this.impulse(
          vi, wi, bi.mass, bi.angularInertia, ri,
          vj, wj, bj.mass, bj.angularInertia, rj,
          ri, 0.99, .2, .1);

      this.applyImpulse(c.i, impulse, ri);
      this.applyImpulse(c.j, this.math.negativeVector(impulse), rj);
      
      var v1 = Math.sqrt(vi[0]*vi[0] + vi[1]*vi[1] + vi[2]*vi[2]);
      var v2 = Math.sqrt(vj[0]*vj[0] + vj[1]*vj[1] + vj[2]*vj[2]);
      // alert("v1 = " + v1 + " : v2 = " + v2);
      
      
      
      var soundVelocity = 10.0 * (v1 + v2);
      if (soundVelocity > 1.0) soundVelocity = 1.0;

      playSound(pingBuffer, soundVelocity, 0, 0);
    }
  };

  this.randomOrientations = function() {
    for (var i = 0; i < 16; ++i) {
      this.balls[i].orientation =
          this.math.normalize([Math.random() - 0.5,
                               Math.random() - 0.5,
                               Math.random() - 0.5,
                               Math.random() - 0.5]);
    }
  };

  this.placeBalls = function() {
    for (var i = 0; i < 16; ++i) {
      var ball = this.balls[i];
      if (!ball.active) {
        g_shadowOnParams[i].value = 0;
        continue;
      }
      var p = ball.center;
      placeBall(i, p[0], p[1], p[2], ball.orientation);
    }
  };

  this.impulse = function(v1, w1, m1, I1, r1,
                          v2, w2, m2, I2, r2,
                          N, e, u_s, u_d) {
    // Just to be safe, make N unit-length.
    N = this.math.normalize(N);

    // Vr is the relative velocity at the point of impact.
    // Vrn and Vrt are the normal and tangential parts of Vr.
    var Vr =
        this.math.subVector(
            this.math.addVector(this.math.cross(w2, r2), v2),
            this.math.addVector(this.math.cross(w1, r1), v1));

    var Vrn = this.math.mulScalarVector(this.math.dot(Vr, N), N);
    var Vrt = this.math.subVector(Vr, Vrn);

    var K = this.math.addMatrix(
        this.intertialTensor(m1, I1, r1), this.intertialTensor(m2, I2, r2));
    var Kinverse = this.math.inverse(K);

    // Compute the impulse assuming 0 tangential velocity.
    var j0 = this.math.mulMatrixVector(Kinverse,
        this.math.subVector(Vr, this.math.mulScalarVector(-e, Vrn)));

    // If j0 is in the static friction cone, we return that.
    // If the length of Vrt is 0, then we cannot normalize it,
    // so we return j0 in that case, too.
    var j0n = this.math.mulScalarVector(this.math.dot(j0, N), N);
    var j0t = this.math.subVector(j0, j0n);

    if (this.math.lengthSquared(j0t) <=
        u_s * u_s * this.math.lengthSquared(j0n) ||
            this.math.lengthSquared(Vrt) == 0.0) {
      return j0;
    }

    // Get a unit-length tangent vector by normalizing the tangent velocity.
    // The friction impulse acts in the opposite direction.
    var T = this.math.normalize(Vrt);

    // Compute the current impulse in the normal direction.
    var jn = this.math.dot(this.math.mulMatrixVector(Kinverse, Vr), N);

    // Compute the impulse assuming no friction.
    var js = this.math.mulMatrixVector(Kinverse,
        this.math.mulScalarVector(1 + e, Vrn));

    // Return the frictionless impulse plus the impulse due to friction.
    return this.math.addVector(js, this.math.mulScalarVector(-u_d * jn, T));
  };

  this.intertialTensor = function(m, I, r) {
    var a = r[0];
    var b = r[1];
    var c = r[2];

    return [[1 / m + (b * b + c * c) / I, (-a * b) / I, (-a * c) / I],
            [(-a * b) / I, 1 / m + (a * a + c * c) / I, (-b * c) / I],
            [(-a * c) / I, (-b * c) / I, 1 / m + (a * a + b * b) / I]];
  };

  this.applyImpulse = function(i, impulse, r) {
    var ball = this.balls[i];
    var v = ball.velocity;
    var w = ball.angularVelocity;

    // v += impulse / mass
    v[0] += impulse[0] / ball.mass;
    v[1] += impulse[1] / ball.mass;

    // w += r x impulse / angularInertia
    w[0] += (-r[2] * impulse[1]) / ball.angularInertia;
    w[1] += (impulse[0] * r[2]) / ball.angularInertia;
    w[2] += (r[0] * impulse[1] - r[1] * impulse[0]) / ball.angularInertia;
  };

  this.ballsImpactFloor = function() {
    for (var i = 0; i < 16; ++i) {
      var ball = this.balls[i];
      if (!ball.active)
        continue;
      var v = ball.velocity;
      v = [v[0], v[1], -0.1];
      var w = ball.angularVelocity;

      var impulse = this.impulse(
          v, w, ball.mass, ball.angularInertia, [0, 0, -1],
          [0, 0, 0], [0, 0, 0], 1e100, 1e100, [0, 0, 1],
          [0, 0, -1], 0.1, 0.2, 0.1);

      this.applyImpulse(i, impulse, [0, 0, -1]);
    }
  };

  this.ballsLoseEnergy = function() {
    for (var i = 0; i < 16; ++i) {
      var ball = this.balls[i];
      if (!ball.active)
        continue;
      var v = ball.velocity;
      var w = ball.angularVelocity;

      var k = 0.999;
      v[0] *= k;
      v[1] *= k;
      w[0] *= k;
      w[1] *= k;
      w[2] *= k;

      var wEpsilon = 0.00003;
      var wLength = this.math.length(w);
      if (wLength < wEpsilon) {
        w[0] = 0;
        w[1] = 0;
        w[2] = 0;
      } else {
        var t = wEpsilon / wLength;
        w[0] -= t * w[0];
        w[1] -= t * w[1];
        w[2] -= t * w[2];
      }
    }
  };
};


function vectorToQuaternion(r) {
  var theta = g_math.length(r);
  var stot = (theta < 1.0e-6)?1:(Math.sin(theta/2) / theta);
  return [stot * r[0], stot * r[1], stot * r[2], Math.cos(theta)];
}


CameraPosition = function() {
  this.center = [0, 0, 0];
  this.theta = -Math.PI / 2;
  this.phi = Math.PI / 2 - 0.1;
  this.radius = 100;
};


DragInfo = function() {
  this.lastX = 0;
  this.lastY = 0;
  this.position = new CameraPosition();
  this.targetPosition = new CameraPosition();
  this.vector_ = [0, 0, 0];
  this.lerpCoefficient = 1;
  this.startingTime = 0;

  this.begin = function(x, y) {
    this.lastX = x;
    this.lastY = y;
  };

  this.update = function(x, y) {
    this.targetPosition.theta -= (x - this.lastX) / 200;
    this.targetPosition.phi += (y - this.lastY) / 200;
    this.bound();
    this.lastX = x;
    this.lastY = y;
  };

  this.bound = function() {
    if (this.position.phi < 0.01) this.position.phi = 0.01;
    if (this.position.phi > Math.PI / 2 - 0.01)
      this.position.phi = Math.PI / 2 - 0.01;

    if (this.targetPosition.phi < 0.01) this.targetPosition.phi = 0.01;
    if (this.targetPosition.phi > Math.PI / 2 - 0.01)
      this.targetPosition.phi = Math.PI / 2 - 0.01;
  };

  this.getEyeAndTarget = function(eye, target) {
    var t = this.lerpCoefficient;
    t = 3 * t * t - 2 * t * t * t;
    var a = this.position;
    var b = this.targetPosition;

    var center = [(1 - t) * a.center[0] + t * b.center[0],
                  (1 - t) * a.center[1] + t * b.center[1],
                  (1 - t) * a.center[2] + t * b.center[2]];
    var radius = (1 - t) * a.radius + t * b.radius;
    var theta = (1 - t) * a.theta + t * b.theta;
    var phi = (1 - t) * a.phi + t * b.phi;

    var cosPhi = Math.cos(phi);
    target[0] = center[0];
    target[1] = center[1];
    target[2] = center[2];
    eye[0] = target[0] + radius * cosPhi * Math.cos(theta);
    eye[1] = target[1] + radius * cosPhi * Math.sin(theta);
    eye[2] = target[2] + radius * Math.sin(phi);
  };

  this.goTo = function(center, theta, phi, radius) {
    if (!center) {
      center = this.targetPosition.center;
    }
    if (!theta) {
      theta = this.targetPosition.theta;
    }
    if (!phi) {
      phi = this.targetPosition.phi;
    }
    if (!radius) {
      radius = this.targetPosition.radius;
    }

    this.targetPosition.center[0] = center[0];
    this.targetPosition.center[1] = center[1];
    this.targetPosition.center[2] = center[2];
    this.targetPosition.theta = theta;
    this.targetPosition.phi = phi;
    this.targetPosition.radius = radius;

    this.lerpCoefficient = 0;
    this.startingTime = g_clock;
  };

  this.backUp = function() {
    this.goTo(null,
              null,
              Math.PI / 6,
              100);
  };

  this.zoomToPoint = function(center) {
    this.goTo(center,
              this.targetPosition.theta,
              Math.PI / 20,
              20);
  };

  this.updateClock = function() {
    this.lerpCoefficient = Math.min(1, g_clock - this.startingTime);
    if (this.lerpCoefficient == 1) {
      this.position.center[0] = this.targetPosition.center[0];
      this.position.center[1] = this.targetPosition.center[1];
      this.position.center[2] = this.targetPosition.center[2];
      this.position.theta = this.targetPosition.theta;
      this.position.phi = this.targetPosition.phi;
      this.position.radius = this.targetPosition.radius;
    }
  };
};

var g_dragInfo = new DragInfo();
var g_dragging = false;

function startDragging(e) {
  g_dragInfo.begin(e.x, e.y);
  g_dragging = true;
}

function drag(e) {
  if (g_dragging) {
    g_dragInfo.update(e.x, e.y);
    updateContext();
  }
}

function stopDragging(e) {
  if (g_dragging) {
    g_dragInfo.update(e.x, e.y);
    updateContext();
  }
  g_dragging = false;
}

function scrollMe(e) {
  g_dragInfo.radius *= (e.deltaY < 0 ? 0.9 : 1.0 / 0.9);
  updateContext();
}

/**
 * Initializes global variables, positions eye, draws shapes.
 * @param {Array} clientElements Array of o3d object elements.
 */
function main(clientElements) {
  initPhysics();
  initGlobals(clientElements);
  initRenderGraph();
  updateContext();
  initMaterials();
  initShadowPlane();
  initTable();
  initHud();
  setUpBalls();
  g_physics.placeBalls();
  setRenderCallback();
  registerEventCallbacks();
}


function registerEventCallbacks() {
  // Execute keyPressed() when we detect a keypress on the window or
  // on the o3d object.

  // Register mouse events handlers
  o3djs.event.addEventListener(g_o3dElement, 'mousedown', startDragging);
  o3djs.event.addEventListener(g_o3dElement, 'mousemove', drag);
  o3djs.event.addEventListener(g_o3dElement, 'mouseup', stopDragging);
  o3djs.event.addEventListener(g_o3dElement, 'wheel', scrollMe);

  o3djs.event.addEventListener(g_o3dElement, 'keypress', keyPressed);
  o3djs.event.addEventListener(g_o3dElement, 'keyup', keyUp);
  o3djs.event.addEventListener(g_o3dElement, 'keydown', keyDown);

  window.g_finished = true;  // for selenium testing.
}


/**
 * Creates the client area.
 */
function initClient() {
  window.g_finished = false;  // for selenium testing.

  o3djs.util.makeClients(main);
}


/**
 * Initializes global variables and libraries.
 */
function initGlobals(clientElements) {
  g_o3dElement = clientElements[0];
  window.g_client = g_client = g_o3dElement.client;
  g_o3d = g_o3dElement.o3d;
  g_math = o3djs.math;
  g_quat = o3djs.quaternions;

  // Create a pack to manage the objects created.
  g_pack = g_client.createPack();
  
  // Audio init
  xaudio = document.getElementById('xaudio');
  xaudio.listener.gain = 2.0;

  loadPing("../sounds/hyper-reality/filter-noise-3.aif");
  loadSoftPing("../sounds/hyper-reality/filter-noise-1.aif");
}

/**
 * Initalizes the render graph.
 */
function initRenderGraph() {
  // Need separate roots for the table, shadow and heads-up display.
  g_tableRoot = g_pack.createObject('Transform');
  g_tableRoot.parent = g_client.root;
  g_shadowRoot = g_pack.createObject('Transform');
  g_shadowRoot.parent = g_client.root;
  g_hudRoot = g_pack.createObject('Transform');
  g_hudRoot.parent = g_client.root;

  // Create the render graph for a view.
  var viewRoot = g_pack.createObject('RenderNode');
  viewRoot.priority = 1;
  if (!SHADOWPOV)
    viewRoot.parent = g_client.renderGraphRoot;

  var shadowPassRoot = g_pack.createObject('RenderNode');
  shadowPassRoot.priority = 0;
  shadowPassRoot.parent = g_client.renderGraphRoot;

  g_viewInfo = o3djs.rendergraph.createBasicView(
      g_pack,
      g_tableRoot,
      viewRoot,
      [0, 0, 0, 1]);

  g_hudViewInfo = o3djs.rendergraph.createBasicView(
      g_pack,
      g_hudRoot,
      g_client.renderGraphRoot);

  // Make sure the hud gets drawn after the 3d scene.
  g_hudViewInfo.root.priority = g_viewInfo.root.priority + 1;

  // Turn off clearing the color for the hud.
  g_hudViewInfo.clearBuffer.clearColorFlag = false;

  // Set culling to none so we can flip images using rotation or negative scale.
  g_hudViewInfo.zOrderedState.getStateParam('CullMode').value =
      g_o3d.State.CULL_NONE;
  g_hudViewInfo.zOrderedState.getStateParam('ZWriteEnable').value = false;

  // Create an orthographic matrix for 2d stuff in the HUD.
  g_hudViewInfo.drawContext.projection = g_math.matrix4.orthographic(
      0, 1, 0, 1, -10, 10);

  g_hudViewInfo.drawContext.view = g_math.matrix4.lookAt(
      [0, 0, 1],   // eye
      [0, 0, 0],   // target
      [0, 1, 0]);  // up

  // Create the texture required for the render-target.
  g_shadowTexture = g_pack.createTexture2D(RENDER_TARGET_WIDTH,
                                           RENDER_TARGET_HEIGHT,
                                           g_o3d.Texture.XRGB8, 1, true);

  var renderSurface = g_shadowTexture.getRenderSurface(0, g_pack);

  // Create the depth-stencil buffer required when rendering the shadows.
  var depthSurface = g_pack.createDepthStencilSurface(RENDER_TARGET_WIDTH,
                                                      RENDER_TARGET_HEIGHT);

  var renderSurfaceSet = g_pack.createObject('RenderSurfaceSet');
  renderSurfaceSet.renderSurface = renderSurface;
  renderSurfaceSet.renderDepthStencilSurface = depthSurface;
  renderSurfaceSet.parent = shadowPassRoot;

  var shadowRenderGraphRoot = renderSurfaceSet;
  if (SHADOWPOV)
    shadowRenderGraphRoot = g_client.renderGraphRoot;

  g_shadowPassViewInfo = o3djs.rendergraph.createBasicView(
      g_pack,
      g_shadowRoot,
      shadowRenderGraphRoot,
      [0, 0, 0, 1]);

  g_shadowPassViewInfo.zOrderedState.
      getStateParam('ZComparisonFunction').value =
          o3djs.base.o3d.State.CMP_ALWAYS;
}

/**
 * Sets up reasonable view and projection matrices.
 */
function updateContext() {
  // Set up a perspective transformation for the projection.
  g_shadowPassViewInfo.drawContext.projection = 
  g_viewInfo.drawContext.projection = g_math.matrix4.perspective(
      g_math.degToRad(30), // 30 degree frustum.
      g_o3dElement.clientWidth / g_o3dElement.clientHeight, // Aspect ratio.
      1,                   // Near plane.
      5000);               // Far plane.

  // Set the view transformation.
  var eye = [0, 0, 0];
  var target = [0, 0, 0];
  g_dragInfo.getEyeAndTarget(eye, target);
  g_shadowPassViewInfo.drawContext.view = 
  g_viewInfo.drawContext.view = g_math.matrix4.lookAt(eye, target, [0, 0, 1]);

  updateMaterials();
}

function initMaterials() {
  g_materials = {
      'felt':{},
      'wood':{},
      'cushion':{},
      'billiard':{},
      'ball':{},
      'shadowPlane':{}};

  // Load shader string from document.
  var shaderString = document.getElementById('effects').value;

  for (name in g_materials) {
    var material = g_pack.createObject('Material');
    g_materials[name] = material;
    var effect = g_pack.createObject('Effect');

    effect.loadFromFXString(shaderString +
        "// #o3d PixelShaderEntryPoint "+name+"PixelShader\n");
    material.effect = effect;
    effect.createUniformParameters(material);
    material.drawList = g_viewInfo.performanceDrawList;

    var eye = [0, 0, 0];
    var target = [0, 0, 0];
    g_dragInfo.getEyeAndTarget(eye, target);

    material.getParam('factor').value = 2 / g_tableWidth;
    material.getParam('lightWorldPosition').value = g_light;
    material.getParam('eyeWorldPosition').value = eye;
  }

  g_materials['shadowPlane'].drawList = g_shadowPassViewInfo.zOrderedDrawList;

  g_shadowSampler = g_pack.createObject('Sampler');
  g_shadowSampler.texture = g_shadowTexture;
  g_materials['felt'].getParam('shadowSampler').value = g_shadowSampler;


  g_solidMaterial = g_pack.createObject('Material');
  o3djs.effect.attachStandardShader(
      g_pack, g_solidMaterial, [-10, 10, 10], 'phong');
  g_solidMaterial.drawList = g_hudViewInfo.zOrderedDrawList;

  g_solidMaterial.getParam('emissive').value = [0, 0, 0, 1];
  g_solidMaterial.getParam('ambient').value = [1, 1, 1, .3];
  g_solidMaterial.getParam('diffuse').value = [1, 1, 1, .3];
  g_solidMaterial.getParam('specular').value = [.2, .2, .2, 1];
  g_solidMaterial.getParam('shininess').value = 20;

  o3djs.io.loadBitmaps(g_pack,
      o3djs.util.getAbsoluteURI('assets/poolballs_new.png'),
      finishLoadingBitmaps);
}

function updateMaterials() {
  for (name in g_materials) {
    var eye = [0, 0, 0];
    var target = [0, 0, 0];
    g_dragInfo.getEyeAndTarget(eye, target);
    g_materials[name].getParam('eyeWorldPosition').value = eye;
  }
}

/**
 * Gets called back when the bitmap has loaded.
 */
function finishLoadingBitmaps(bitmaps, exception) {
  var bitmap = bitmaps[0];
  bitmap.flipVertically();
  var width = bitmaps[0].width / 4;
  var height = bitmaps[0].height / 4;
  var levels = o3djs.texture.computeNumLevels(width, height);

  for (var i = 0; i < 16; ++i) {
    g_ballTextures[i] = g_pack.createTexture2D(
        width, height, g_o3d.Texture.XRGB8, 0, false);
    g_ballTextureSamplers[i] = g_pack.createObject('Sampler');
    g_ballTextureSamplers[i].texture = g_ballTextures[i];
  }

  for (var i = 0; i < 16; ++i) {
    var u = i % 4;
    var v = Math.floor(i / 4);
    g_ballTextures[i].drawImage(bitmap,
        0, u * width, v * height, width, height,
        0, 0, 0, width, height);
    g_ballTextures[i].generateMips(0, levels - 1);
  }

  for (var i = 0; i < 16; ++i) {
    g_ballTextureSamplerParams[i].value = g_ballTextureSamplers[i];
  }
}

function flatMesh(material, vertexPositions, faceIndices) {
  var vertexInfo = o3djs.primitives.createVertexInfo();
  var positionStream = vertexInfo.addStream(
      3, o3djs.base.o3d.Stream.POSITION);
  var normalStream = vertexInfo.addStream(
      3, o3djs.base.o3d.Stream.NORMAL);

  var vertexCount = 0;
  for (var i = 0; i < faceIndices.length; ++i) {
    var face = faceIndices[i];

    var n = g_math.normalize(g_math.cross(
        g_math.subVector(vertexPositions[face[1]],
                         vertexPositions[face[0]]),
        g_math.subVector(vertexPositions[face[2]],
                         vertexPositions[face[0]])));

    var faceFirstIndex = vertexCount;

    for (var j = 0; j < face.length; ++j) {
      var v = vertexPositions[face[j]];
      positionStream.addElement(v[0], v[1], v[2]);
      normalStream.addElement(n[0], n[1], n[2]);
      ++vertexCount;
    }

    for (var j = 1; j < face.length - 1; ++j)
      vertexInfo.addTriangle(faceFirstIndex,
                             faceFirstIndex + j,
                             faceFirstIndex + j + 1);
    }

  return vertexInfo.createShape(g_pack, material);
}

function arc(center, radius, start, end, steps) {
  var r = [];

  for (var i = 0; i <= steps; ++i) {
    var theta = start + i * (end - start) / steps;
    r.push([center[0] + radius * Math.cos(theta),
            center[1] + radius * Math.sin(theta)]);
  }
  return r;
}

function myreverse(l) {
  var r = [l[0]];
  var n = l.length;
  for (var i = 0; i < n - 1; ++i) {
    r.push(l[n - i - 1]);
  }
  return r;
}

function flip(a, b) {
  r = [];
  for (var i = 0; i < a.length; ++i)
    r.push([b[0] * a[i][0], b[1] * a[i][1]]);
  if (b[0] * b[1] < 0)
    return myreverse(r);
  return r;
}


var g_pocketRadius = 2.3;
var g_woodBreadth = 3.2;
var g_tableThickness = 5;
var g_tableWidth = 45;
var g_woodHeight = 1.1;

function initTable() {
  var feltMaterial = g_materials.felt;
  var woodMaterial = g_materials.wood;
  var cushionMaterial = g_materials.cushion;
  var billiardMaterial = g_materials.billiard;

  var shapes = [];

  var root = g_pack.createObject('Transform');
  root.parent = g_tableRoot;
  var tableRoot = g_pack.createObject('Transform');
  tableRoot.translate(0, 0, -g_tableThickness / 2 - 1);
  var cushionRoot = g_pack.createObject('Transform');
  var ballRoot = g_pack.createObject('Transform');
  tableRoot.parent = root;
  cushionRoot.parent = tableRoot;
  ballRoot.parent = root;

  var root2 = Math.sqrt(2);

  var scaledPocketRadius = 2 * g_pocketRadius / g_tableWidth;
  var scaledWoodBreadth = 2 * g_woodBreadth / g_tableWidth;

  var felt_polygon_A =
      [[0, -2], [0, (1 + .5 * root2) * scaledPocketRadius - 2]].concat(
          arc([.5 * root2 * scaledPocketRadius - 1,
             .5 * root2 * scaledPocketRadius - 2],
              scaledPocketRadius, Math.PI / 2, -.25 * Math.PI, 15));

  var felt_polygon_B =
      [[-1, (1 + .5 * root2) * scaledPocketRadius - 2]].concat(
          arc([.5 * root2 * scaledPocketRadius - 1,
             .5 * root2 * scaledPocketRadius - 2],
              scaledPocketRadius, .75 * Math.PI, .5 * Math.PI, 15));

  var felt_polygon_C =
      [[0, (1 + .5 * root2) * scaledPocketRadius - 2], [0, 0]].concat(
          arc([-1, 0], scaledPocketRadius, 0, -.5 * Math.PI, 15)).concat(
              [[-1, (1 + .5 * root2) * scaledPocketRadius - 2]]);

  var wood_polygon =
      [[-scaledWoodBreadth - 1, -scaledWoodBreadth - 2],
       [0, -scaledWoodBreadth - 2],
       [0, -2]].concat(
           arc([.5 * root2 * scaledPocketRadius - 1,
              .5 * root2 * scaledPocketRadius - 2],
             scaledPocketRadius,
             -.25 * Math.PI,
             -1.25 * Math.PI,
             15)).concat(
                  arc([-1, 0],
                    scaledPocketRadius,
                    1.5 * Math.PI,
                    Math.PI,
                    15)).concat([[-scaledWoodBreadth - 1, 0]]);

  var m = g_math.mulScalarMatrix(g_tableWidth / 2, g_math.identity(2));
  felt_polygon_A = g_math.mulMatrixMatrix(felt_polygon_A, m);
  felt_polygon_B = g_math.mulMatrixMatrix(felt_polygon_B, m);
  felt_polygon_C = g_math.mulMatrixMatrix(felt_polygon_C, m);
  wood_polygon = g_math.mulMatrixMatrix(wood_polygon, m);

  var felt_polygons = [];
  var wood_polygons = [];
  for (var i = -1; i < 2; i+=2) {
    for (var j = -1; j < 2; j+=2) {
      felt_polygons.push(flip(felt_polygon_A, [i, j]),
                         flip(felt_polygon_B, [i, j]),
                         flip(felt_polygon_C, [i, j]));
      wood_polygons.push(flip(wood_polygon, [i, j]));
    }
  }

  for (var i = 0; i < felt_polygons.length; ++i) {
    shapes.push(o3djs.primitives.createPrism(
          g_pack,
          feltMaterial,
          felt_polygons[i], g_tableThickness));
  }

  for (var i = 0; i < wood_polygons.length; ++i) {
    shapes.push(o3djs.primitives.createPrism(
          g_pack,
          woodMaterial,
          wood_polygons[i], g_tableThickness + 2 * g_woodHeight));
  }

  for (var i = 0; i < 1; i++) {
    var t = g_pack.createObject('Transform');
    t.parent = tableRoot;
    for (var j = 0; j < shapes.length; ++j) {
      t.addShape(shapes[j]);
    }
  }

  var cushionHeight = 1.1 * g_woodHeight;
  var cushionUp = g_tableThickness / 2;
  var cushionProp = .9 * g_woodHeight;
  var cushionDepth = g_tableWidth;
  var cushionBreadth = g_pocketRadius;
  var cushionSwoop = g_pocketRadius;

  var angles = [0, Math.PI/2, Math.PI, Math.PI, 3 * Math.PI / 2, 0];
  var translations = g_math.mulMatrixMatrix(
      [[-1, -1, 0], [0, -2, 0], [1, -1, 0], [1, 1, 0], [0, 2, 0], [-1, 1, 0]],
      [[g_tableWidth / 2, 0, 0], [0, g_tableWidth / 2, 0], [0, 0, 1]]);
  var shortenings = g_math.mulScalarMatrix(g_pocketRadius,
      [[1, root2], [root2, root2], [root2, 1]])

  var billiardThickness = 0.1;
  var billiardBreadth = 1;
  var billiardDepth = .309;
  var billiardOut = -g_woodBreadth / 2;
  var billiardSpacing = g_tableWidth / 4;

  var billiards = [];

  for (var i = -1; i < 2; ++i) {
    billiards.push(o3djs.primitives.createPrism(
        g_pack,
        billiardMaterial,
        [[billiardOut + billiardBreadth / 2, i * billiardSpacing],
         [billiardOut, billiardDepth + i * billiardSpacing],
         [billiardOut - billiardBreadth / 2, i * billiardSpacing],
         [billiardOut, -billiardDepth + i * billiardSpacing]],
        g_tableThickness + 2 * g_woodHeight + billiardThickness));
  }

  for (var i = 0; i < 6; ++i) {
    var backShortening = shortenings[i % 3][1];
    var frontShortening = shortenings[i % 3][0];

    var vertexPositions = [
      [0, -cushionDepth / 2 + backShortening, cushionUp],
      [cushionBreadth, -cushionDepth / 2 + cushionSwoop + backShortening,
       cushionUp + cushionProp],
      [cushionBreadth, -cushionDepth / 2 + cushionSwoop + backShortening,
       cushionUp + cushionHeight],
      [0, -cushionDepth / 2 + backShortening, cushionUp + cushionHeight],
      [0, cushionDepth / 2 - frontShortening, cushionUp],
      [cushionBreadth, cushionDepth / 2 - cushionSwoop - frontShortening,
       cushionUp + cushionProp],
      [cushionBreadth, cushionDepth / 2 - cushionSwoop - frontShortening,
       cushionUp + cushionHeight],
      [0, cushionDepth / 2 - frontShortening, cushionUp + cushionHeight]
    ];

    var faceIndices = [
      [0, 1, 2, 3], // front
      [7, 6, 5, 4], // back
      [1, 0, 4, 5], // bottom
      [2, 1, 5, 6], // right
      [3, 2, 6, 7], // top
      [0, 3, 7, 4]  // left
    ];

    var cushion = flatMesh(cushionMaterial, vertexPositions, faceIndices);
    shapes.push(cushion);

    var t = g_pack.createObject('Transform');
    t.localMatrix = g_math.mulMatrixMatrix(
        g_math.matrix4.rotationZ(angles[i]),
        g_math.matrix4.translation(translations[i]));

    t.parent = cushionRoot;
    t.addShape(cushion);
    for (var j = 0; j < billiards.length; ++j)
      t.addShape(billiards[j]);
  }

  for (var j = 0; j < billiards.length; ++j)
    shapes.push(billiards[j]);

  var ball =
      o3djs.primitives.createSphere(g_pack, g_materials.ball, 1, 50, 70);
  shapes.push(ball);

  for(var i = 0; i < 16; ++i) {
    var transform = g_pack.createObject('Transform');
    g_ballTextureSamplerParams[i] =
        transform.createParam('textureSampler', 'ParamSampler');
    transform.parent = ballRoot;
    g_ballTransforms[i] = transform;
    transform.addShape(ball);
  }

  // Important that this stay at the end of the function.
  for (var j = 0; j < shapes.length; ++j)
    shapes[j].createDrawElements(g_pack, null);
}


function initHud() {
  var barT1 = g_pack.createObject('Transform');
  g_barScaling = g_pack.createObject('Transform');
  var barT2 = g_pack.createObject('Transform');

  barT1.parent = g_hudRoot;
  g_barScaling.parent = barT1;
  barT2.parent = g_barScaling;

  var plane = o3djs.primitives.createPlane(
      g_pack, g_solidMaterial, 1, 1, 1, 1,
      [[1, 0, 0, 0], [0, 0, 1, 0], [0,-1, 0, 0], [0, 0, 0, 1]]);

  barT2.addShape(plane);

  barT1.translate([0.05, 0.05, 0]);
  barT1.scale([0.05, 0.9, 1]);
  g_barScaling.localMatrix = g_math.matrix4.scaling([1, 0.0, 1]);
  barT2.translate([.5, .5, 0]);
}

function setBarScale(t) {
  g_barScaling.localMatrix = g_math.matrix4.scaling([1, t, 1]);
}


function setUpBalls() {
  rackFor8Ball(6.0 * g_tableWidth / 12.0, -g_tableWidth / 2);
  g_physics.randomOrientations();
}


function onrender(renderEvent) {
  var elapsedTime = renderEvent.elapsedTime;
  g_clock += elapsedTime;
  
  if (g_dragInfo) {
    g_dragInfo.updateClock();
  }

  if (g_physics) {
    if (g_physics.someBallsMoving()) {
      g_physics.step();
      g_physics.stopSlowBalls();
    }
  }
  updateContext();
}


function initPhysics() {
  g_physics = new pool.Physics();
  g_physics.math = o3djs.math;
  g_physics.quat = o3djs.quaternions;

  g_physics.left = -g_tableWidth / 2 + g_pocketRadius + 1;
  g_physics.right = g_tableWidth / 2 - g_pocketRadius - 1;
  g_physics.top = g_tableWidth - g_pocketRadius - 1;
  g_physics.bottom = - g_tableWidth + g_pocketRadius + 1;

  var w = g_tableWidth / 2;
  var r = g_pocketRadius;
  var root2 = Math.sqrt(2);
  var x = .5 * root2 * r - w;
  var y = .5 * root2 * r - 2 * w;

  g_physics.pocketCenters = [
    [w, 0], [-w, 0], [x, y], [-x, y], [x, -y], [-x, -y]];

  g_physics.pocketRadius = g_pocketRadius;
  g_physics.tableWidth = g_tableWidth;

  g_physics.initWalls();
}


function setRenderCallback() {
  g_client.setRenderCallback(onrender);
}


function rackFor8Ball(yOffset, cueYOffset) {
  var root3 = Math.sqrt(3);

  placeBall(1, 0, 0 + yOffset);
  placeBall(9, -1, root3 + yOffset);
  placeBall(2, 1, root3 + yOffset);
  placeBall(10, 2, 2 * root3 + yOffset);
  placeBall(8, 0, 2 * root3 + yOffset);
  placeBall(3, -2, 2 * root3 + yOffset);
  placeBall(11, -3, 3 * root3 + yOffset);
  placeBall(4, -1, 3 * root3 + yOffset);
  placeBall(12, 1, 3 * root3 + yOffset);
  placeBall(5, 3, 3 * root3 + yOffset);
  placeBall(13, 4, 4 * root3 + yOffset);
  placeBall(6, 2, 4 * root3 + yOffset);
  placeBall(14, 0, 4 * root3 + yOffset);
  placeBall(15, -2, 4 * root3 + yOffset);
  placeBall(7, -4, 4 * root3 + yOffset);

  placeBall(0, 0, cueYOffset);

  //g_physics.velocities[0] = [0, 1];
  //g_physics.angularVelocities[0] = [.1, 0, 0];
}


function placeBall(i, x, y, z, q) {
  if (!q) {
    q = [0, 0, 0, 1];
  }
  if (!z) {
    z = 0;
  }
  g_physics.balls[i].center[0] = x;
  g_physics.balls[i].center[1] = y;
  g_physics.balls[i].center[2] = z;
  g_ballTransforms[i].localMatrix = g_math.matrix4.translation([x, y, z]);
  g_ballTransforms[i].quaternionRotate(q);
  g_centers[i].value = [x, y];
}


function initShadowPlane() {
  var root = g_pack.createObject('Transform');
  root.parent = g_shadowRoot;

  var plane = o3djs.primitives.createPlane(g_pack,
                                           g_materials.shadowPlane,
                                           g_tableWidth,
                                           g_tableWidth * 2,
                                           1, 
                                           1);
  root.translate([0, 0, -1]);
  root.rotateX(Math.PI / 2);

  plane.createDrawElements(g_pack, null);

  for (var i = 0; i < 16; ++i) {
    var transform = g_pack.createObject('Transform');
    transform.parent = root;
    g_centers.push(transform.createParam('ballCenter', 'ParamFloat2'));
    g_shadowOnParams[i] =
        transform.createParam('shadowOn', 'ParamFloat');
    g_shadowOnParams[i].value = 1;
    transform.addShape(plane);
  }
}


// Hack to avoid problem where user just taps space bar instead of holding for
// more thrust.  If the user doesn't hold the button down for a few ticks
// showing 'seriousness' the stroke doesn't take.
var g_seriousness = 0;

function keyUp(event) {
  switch (event.keyCode) {
    case 32:
      if (g_physics.speedFactor > 0.0) {
        var eye = [0, 0, 0];
        var target = [0, 0, 0];
        g_dragInfo.getEyeAndTarget(eye, target);
        var dx = target[0] - eye[0];
        var dy = target[1] - eye[1];
        var norm = Math.sqrt(dx * dx + dy * dy);
        g_physics.impartSpeed(0, [dx / norm, dy / norm]);
        g_dragInfo.backUp();
      }
      g_physics.speedFactor = 0;
      g_seriousness = 0;
      setBarScale(g_physics.speedFactor);
      break;
  }
}

function keyDown(event) {
  switch (event.keyCode) {
    case 32:
      //g_seriousness = 0;
      //g_physics.speedFactor = 0;
      //setBarScale(0);
      break;
  }
}

function keyPressed(event) {
  var keyChar = String.fromCharCode(o3djs.event.getEventKeyChar(event));
  keyChar = keyChar.toLowerCase();
  var identifier = o3djs.event.getKeyIdentifier(event.charCode, event.keyCode);

  switch (identifier) {
    case 'Left':
        g_dragInfo.targetPosition.theta -= 0.01;
        g_dragInfo.bound();
      break;

    case 'Right':
        g_dragInfo.targetPosition.theta += 0.01;
        g_dragInfo.bound();
      break;

    case 'Up':
        g_dragInfo.targetPosition.phi += 0.01;
        g_dragInfo.bound();
      break;

    case 'Down':
        g_dragInfo.targetPosition.phi -= 0.01;
        g_dragInfo.bound();
      break;
  }

  var spotDelta = 1;
  var cueBall = g_physics.balls[0];
  var x = cueBall.center[0];
  var y = cueBall.center[1];

  switch(keyChar) {
    case 'r':
      if (g_physics.balls[0].active) {
        g_physics.balls[0].active = false;
        g_shadowOnParams[0].value = 0;
        
      } else {
        g_physics.balls[0].active = true;
        g_physics.balls[0].sunkInPocket = -1;
        g_shadowOnParams[0].value = 1;
      }
    break;

    case 'd':
      placeBall(0, x + spotDelta, y);
      break;

    case 'a':
      placeBall(0, x - spotDelta, y);
      break;

    case 's':
      placeBall(0, x, y - spotDelta);
      break;

    case 'w':
      placeBall(0, x, y + spotDelta);
      break;
  }

  switch(keyChar) {
    case 'c':
      g_dragInfo.zoomToPoint(g_physics.balls[0].center);
      break;

    case 't':
      g_dragInfo.goTo([0, 0, 0], null, null, 100);
      break;

    case '=':
      g_dragInfo.targetPosition.radius *= 0.9;
      break;

    case '-':
      g_dragInfo.targetPosition.radius /= 0.9;
      break;

    case ' ':
      if (g_seriousness > 1) {
        g_physics.speedFactor += 0.01;
        if (g_physics.speedFactor > 1)
          g_physics.speedFactor = 1;
        setBarScale(g_physics.speedFactor);
      }
      g_seriousness++;
      break;
  }

  updateContext();
}

</script>
</head>
<body onload="initClient()">
<h1>8 Ball</h1>
<br/>
<!-- Start of O3D plugin -->
<div id="o3d" style="width: 1000px; height: 600px;"></div>
<!-- End of O3D plugin -->

Keys:<br>
c: Cue ball view.<br>
Hold-down-spacebar to shoot.<br>
asdw: Position the cue ball.<br>
r: Toggle cue ball active.<br>
t: View center of the table.<br>
+/-: Zoom in / out.

<div style="display:none">
<!-- Start of effect -->
<textarea id="effects">
  uniform float4x4 worldViewProjection : WorldViewProjection;
  uniform float4x4 worldInverseTranspose : WorldInverseTranspose;
  uniform float4x4 worldViewProjectionInverse : WorldViewProjectionInverse;
  uniform float4x4 world : World;

  uniform float3 lightWorldPosition;
  uniform float3 eyeWorldPosition;
  uniform float factor;
  uniform float shadowOn;

  sampler textureSampler;
  sampler shadowSampler;

  uniform float2 ballCenter;

  struct VertexShaderInput {
    float4 position : POSITION;
    float3 normal : NORMAL;
  };

  struct PixelShaderInput {
    float4 position : POSITION;
    float4 objectPosition : TEXCOORD0;
    float3 worldPosition : TEXCOORD1;
    float4 screenPosition : TEXCOORD3;
    float3 normal : TEXCOORD2;
  };

  PixelShaderInput vertexShaderFunction(VertexShaderInput input) {
    PixelShaderInput output;
    output.position = mul(input.position, worldViewProjection);
    float4 temp = output.position;
    temp += temp.w * float4(1, 1, 0, 0);
    temp.xyz /= 2;
    output.screenPosition = temp;
    output.normal = mul(float4(input.normal, 0), worldInverseTranspose).xyz;
    output.worldPosition = mul(float4(input.position.xyz, 1), world).xyz;
    output.objectPosition = input.position;
    return output;
  }

  float4 roomColor(float3 p, float3 r) {
    float2 c = float2(1.0 / 15.0, 1.0 / 30.0) *
        (p.xy + r.xy * (lightWorldPosition.z - p.z) / r.z);

    float temp = (abs(c.x + c.y) + abs(c.y - c.x));
    float t = min(.15 * max(7 - temp, 0) + (temp < 5), 1);
    return float4(t, t, t, 1);
  }

  float4 lighting(PixelShaderInput input, float4 pigment, float shininess) {
    float3 p = input.worldPosition;
    float3 l = normalize(lightWorldPosition - p);  // Toward light.
    float3 n = normalize(input.normal);            // Normal.
    float3 v = normalize(eyeWorldPosition - p);    // Toward eye.
    float3 r = normalize(-reflect(v, n));          // Reflection of v across n.

    return pigment * dot(l, n) +
        0.2 * float4(1, 1, 1, 1) * pow(max(dot(l, r), 0), shininess);
  }

  float4 woodPigment(float3 p) {
    float3 core = normalize(
        (abs(p.y) > abs(p.x) + 1) ? float3(1, 0.2, 0.3) : float3(0.2, 1, 0.3));
    float grainThickness = 0.02;
    float t = 
        fmod(length(p - dot(p,core)*core), grainThickness) / grainThickness;

    return lerp(float4(.15, .05, 0, 1), float4(0.1, 0, 0, 1), t);
  }

  float4 feltPigment(float3 p) {
    return float4(0, 0.35, .05, 1) + 0.1 * float4(1, 1, 1, 0);
  }

  float4 environmentColor(float3 p, float3 r) {
    float4 upColor = 0.1 * roomColor(p, r);
    float4 downColor = -r.z * 0.3 * feltPigment(p);
    float t = smoothstep(0, 0.05, r.z);
    return lerp(downColor, upColor, t);
  }

  float4 feltPixelShader(PixelShaderInput input): COLOR {
    float2 tex = input.screenPosition.xy / input.screenPosition.w;
    tex.y = -tex.y;

    float3 p = factor * input.worldPosition;
    float3 c = factor * eyeWorldPosition.xyz;
    float width = 0.3;
    float height = 0.3;
    float d =
        1.0 * (smoothstep(1.0 - width, 1.0 + width, abs(p.x)) +
               smoothstep(2.0 - height, 2.0 + height, abs(p.y)));
    p = input.worldPosition;

    return (1 - tex2D(shadowSampler, tex).x - d) * 
        (lighting(input, feltPigment(p), 4));
  }

  float4 woodPixelShader(PixelShaderInput input): COLOR {
    float3 p = factor * input.worldPosition;
    return lighting(input, woodPigment(p), 50);
  }

  float4 cushionPixelShader(PixelShaderInput input): COLOR {
    float3 p = factor * input.worldPosition;
    return lighting(input, feltPigment(p), 4);
  }

  float4 billiardPixelShader(PixelShaderInput input): COLOR {
    float3 p = factor * input.worldPosition;
    return lighting(input, float4(.5, .5, .2, 1), 30);
  }

  float4 ballPixelShader(PixelShaderInput input): COLOR {
    float3 p = normalize(input.objectPosition.xyz);
    float4 u = .5 * float4(p.x, p.y, p.x, -p.y);
    u = clamp(u, -0.45, 0.45);
    u += float4(0.5, 0.5, 0.5, 0.5);

    float t = clamp(5 * p.z, 0, 1);

    p = input.worldPosition;
    float3 l = normalize(lightWorldPosition - p);  // Toward light.
    float3 n = normalize(input.normal);            // Normal.
    float3 v = normalize(eyeWorldPosition - p);    // Toward eye.
    float3 r = normalize(-reflect(v, n));          // Reflection of v across n.

    float4 pigment =
        lerp(tex2D(textureSampler, u.zw), tex2D(textureSampler, u.xy), t);

    return 0.4 * environmentColor(p, r) +
        pigment * (0.3 * smoothstep(0, 1.1, dot(n, l)) +
                   0.3 * (p.z + 1));
  }

  float4 shadowPlanePixelShader(PixelShaderInput input): COLOR {
    float2 p = input.worldPosition.xy - ballCenter;
    float2 q = (input.worldPosition.xy / lightWorldPosition.z);

    float2 offset = (1.0 - 1.0 / (float2(1,1) + abs(q))) * sign(q);
    float t = lerp(smoothstep(.9, 0, length(p - length(p) * offset) / 2), 
                   smoothstep(1, 0, length(p) / 10), .15);
    return shadowOn * float4(t, t, t, t);
  }

  // #o3d MatrixLoadOrder RowMajor
  // #o3d VertexShaderEntryPoint vertexShaderFunction
  // Pixel shader to be appended in javascript.
</textarea>
<!-- End of effect -->
</div>

<!-- Start of xaudio -->
<xaudio id="xaudio"></xaudio>

</body>
</html>

