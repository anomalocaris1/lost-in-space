<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
 
<html xmlns="http://www.w3.org/1999/xhtml"> 
  <head> 
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /> 
    <title>Web Audio API</title> 
    <meta name="revision" content="$Id: Overview.html,v 1.1 2010/24/05 13:16:24 crogers Exp $" /> 
    <link rel="stylesheet" href="style.css" type="text/css" /> 
    <script src="section-links.js" type="application/ecmascript"></script> 
    <script src="dfn.js" type="application/ecmascript"></script> 
    <!--[if IE]>
    <style type='text/css'>
      .ignore {
        -ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=50)";
        filter: alpha(opacity=50);
      }
    </style>
    <![endif]--> 
 
    
  <link rel="stylesheet" href="http://www.w3.org/StyleSheets/TR/W3C-WD" type="text/css" /></head> 
 
  <body> 
    <div class="head"><div><a href="http://www.w3.org/"><img src="http://www.w3.org/Icons/w3c_home" width="72" height="48" alt="W3C" /></a></div><h1>Web Audio API</h1>
    <h2>W3C Audio Incubator Group Proposal <em>24 May 2010</em>
    </h2>
    <dl>
    <dt>Change History: <a href="#ChangeLog-section">here</a></dt>
    <dt>Editor:</dt><dd>Chris Rogers, Google &lt;crogers@google.com&gt;</dd></dl>
    <dt>HTML modified from <a href="http://www.w3.org/TR/FileAPI/#references">File API</a> </dt>
    <p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> &copy; 2009 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>&reg;</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.org/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.
</p></div><hr /> 

    <div class="section"> 
      <h2>Abstract</h2> 
     <p> 
      This specification describes a high-level JavaScript <acronym title="Application Programming Interface">API</acronym> for processing and synthesizing audio in web applications.  The primary paradigm
      is of an audio routing graph, where a number of <a href="#AudioNode-section"><code>AudioNode</code></a> objects are connected together to define the overall audio rendering.  The actual processing will primarily take place
      in the underlying implementation (typically optimized Assembly / C / C++ code), but <a href="#JavaScriptProcessing-section">direct JavaScript processing and synthesis</a> is also supported.

     </p>
      
    <p>
      The interfaces defined are:
    </p> 
    
	<ul> 
	    <li>An <a class="dfnref" href="#AudioNode-section">AudioNode</a> interface, which represents audio sources, audio outputs, and intermediate processing modules.
	    AudioNodes can be dynamically connected together in a <a href="#ModularRouting-section">modular fashion</a>.
	    </li> 
	    
	    <li>An <a class="dfnref" href="#AudioContext-section">AudioContext</a> interface, which contains an audio signal graph representing connections betweens AudioNodes.
	    </li> 

	    <li>An <a class="dfnref" href="#AudioSourceNode-section">AudioSourceNode</a> interface, an abstract AudioNode subclass representing a node which generates audio.
	    </li> 

	    <li>An <a class="dfnref" href="#AudioDestinationNode-section">AudioDestinationNode</a> interface,
	     an AudioNode subclass representing the final destination for all rendered audio.
	    </li> 

	    <li>An <a class="dfnref" href="#AudioParam-section">AudioParam</a> interface, for controlling an individual aspect of an AudioNode's functioning, such as volume.
	    </li> 

	    <li>An <a class="dfnref" href="#AudioBuffer-section">AudioBuffer</a> interface, for working with memory-resident audio assets.  These can represent one-shot sounds,
	    or longer audio clips.
	    </li>

	    <li>An <a class="dfnref" href="#AudioBufferSourceNode-section">AudioBufferSourceNode</a> interface, an AudioNode which generates audio from an AudioBuffer.
	    </li> 


	    <li>An <a class="dfnref" href="#AudioGainNode-section">AudioGainNode</a> interface, for explicit gain control.  Because inputs to AudioNodes support multiple connections
	     (as a unity-gain summing junction), mixers can be <a href="#MixerGainStructure-section">easily built</a> with AudioGainNodes. 
	    </li> 

	    <li>An <a class="dfnref" href="#DelayNode-section">DelayNode</a> interface, an AudioNode which applies a dynamically adjustable variable delay.
	    </li> 

	    <li>An <a class="dfnref" href="#AudioPannerNode-section">AudioPannerNode</a> interface, for spatializing / positioning audio in 3D space.
	    </li> 

	    <li>An <a class="dfnref" href="#AudioListener-section">AudioListener</a> interface, which works with an <code>AudioPannerNode</code> for spatialization.
	    </li> 

	    <li>An <a class="dfnref" href="#ImpulseResponse-section">ImpulseResponse</a> interface, which defines a linear effect (such as the sound of a concert hall) to be loaded into a ConvolverNode.
	    </li> 

	    <li>A <a class="dfnref" href="#ConvolverNode-section">ConvolverNode</a> interface, an AudioNode for applying a real-time linear effect (such as the sound of a concert hall).
	    </li> 

	    <li>A <a class="dfnref" href="#RealtimeAnalyserNode-section">RealtimeAnalyserNode</a> interface, for use with music visualizers, or other visualization applications.
	    </li> 

	    <li>A <a class="dfnref" href="#AudioChannelSplitter-section">AudioChannelSplitter</a> interface,
	     for accessing the individual channels of an audio stream in the routing graph.
	    </li> 

	    <li>A <a class="dfnref" href="#AudioChannelMerger-section">AudioChannelMerger</a> interface,
	     for combining channels from multiple audio streams into a single audio stream.
	    </li> 


        </ul> 
        
        Additionally, a more complex implementation can have the following:
        
        <ul> 

	    <li>The following linear filters can be implemented efficiently as "biquad" filters (two poles, two zeroes).  Each would be a subclass of AudioNode, or
	    there could simply be a BiquadFilterNode which could be configured in different ways:
	    <ul>
            <li> LowPass1Filter </li>
            <li> HighPass1Filter </li>
            <li> LowPass2Filter </li>
            <li> HighPass2Filter </li>
            <li> LowShelfFilter </li>
            <li> HighShelfFilter </li>
            <li> PeakingFilter </li>
            <li> NotchFilter </li>
            <li> Allpass2Filter </li>
	    </ul>
	    
	    </li> 


	    <li>An <a class="dfnref" href="#dfn-AudioCurve">AudioCurve</a> interface, for implementing high-resolution automation, including LFOs (low frequency oscillators),
	        envelopes, and volume fade curves.
	    </li> 

	    <li>A <a class="dfnref" href="#dfn-WaveShaperNode">WaveShaperNode</a> interface, an AudioNode which applies a non-linear waveshaping effect for distortion and other more subtle
	    warming effects.
	    </li> 

	    <li>A <a class="dfnref" href="#dfn-DynamicsProcessorNode">DynamicsProcessorNode</a> interface, an AudioNode for dynamic-shaping (compressor / expander) effects.
	    </li> 

	    <li>A <a class="dfnref" href="#dfn-ChorusNode">ChorusNode</a> interface, an AudioNode implementing a chorus effect.
	    </li> 
 
        </ul> 
  
  <p>The <a href="#introduction">introductory</a> section covers the motivation behind this specification..</p> 
    <p> 
      This API is designed to be used in conjunction with other APIs and elements on the web platform,
      notably: <a href="#XHR2" class="dfnref">XMLHttpRequest</a> (using the <code>responseBlob</code> attribute).
      For games and interactive applications, it is anticipated to be used with the <code>canvas</code> and WebGL APIs for 2D and 3D graphics.      
    </p> 
 
      
    </div> 
 
    <div class="section"> 
      <h2>Status of this Document</h2> 
      <p><em> 
        This section describes the status of this document at the time of
        its publication.  Other documents may supersede this document. A list
        of current W3C publications and the latest revision of this technical
        report can be found in the <a href="http://www.w3.org/TR/">W3C technical
          reports index</a> at http://www.w3.org/TR/.
      </em></p><p> 
        This document is the 24 May 2010 <b>First Audio Incubator Proposal</b> for the
        <cite>Web Audio API</cite> specification.
      
      Please send comments about this document to &lt;public-xg-audio@w3.org&gt (the audio incubator mailing list) or &lt;crogers@google.com&gt;.
    </p> 
      
      <p> 
      <em>This section describes the status of this document at the time of its publication.
      Other documents may supersede this document, since it is only an editor's draft.
      A list of current <acronym title="World Wide Web Consortium">W3C</acronym> 
      publications and the latest revision of this technical report can be found in the 
      <a href="http://www.w3.org/TR/"><acronym title="World Wide Web Consortium">W3C</acronym> 
      technical reports index</a> at http://www.w3.org/TR/.</em> 
      </p> 
 
    <p> 
      Web content and browser developers are encouraged to review this draft.
    </p> 

      <p> 
          Publication as a Working Draft does not imply endorsement by the
          W3C Membership.  This is a draft document and may be updated, replaced
          or obsoleted by other documents at any time. It is inappropriate to cite
          this document as other than work in progress.
        </p>

    </div> 
 
    <div id="toc"> 
      <h2>Table of Contents</h2> 
      <div class="toc"><ul>

          <li><a href="#introduction">
          1. Introduction</a></li>
      
          <li> <a href="#conformance">
          2. Conformance</a></li>
      
          <li> <a href="#terminology">
          3. Terminology and Algorithms</a></li>
      
          <li> <a href="#AudioNode-section">
          4. The AudioNode Interface</a>
          
          <ul>
              <li><a href="#attributes-AudioNode">
              4.1. Attributes</a></li>

              <li><a href="#methodsandparams-AudioNode">
              4.2. Methods and Parameters</a></li>
          </ul>

          </li>
      
          <li><a href="#AudioContext-section">
          5. The AudioContext Interface</a></li>

          <li><a href="#AudioSourceNode-section">
          6. The AudioSourceNode Interface</a></li>
      
          <li><a href="#AudioDestinationNode-section">
          7. The AudioDestinationNode Interface</a></li>
      
          <li><a href="#AudioParam-section">
          8. The AudioParam Interface</a></li>

          <li><a href="#AudioGain-section">
          9. The AudioGain Interface</a></li>

          <li><a href="#AudioGainNode-section">
          10. The AudioGainNode Interface</a></li>
      
          <li><a href="#DelayNode-section">
          11. The DelayNode Interface</a></li>
      
          <li><a href="#AudioBuffer-section">
          12. The AudioBuffer Interface</a></li>

          <li><a href="#AudioBufferSourceNode-section">
          13. The AudioBufferSourceNode Interface</a></li>

          <li><a href="#MediaElementAudioSourceNode-section">
          14. The MediaElementAudioSourceNode Interface</a></li>

          <li><a href="#AudioPannerNode-section">
          15. The AudioPannerNode Interface</a></li>

          <li><a href="#AudioListener-section">
          16. The AudioListener Interface</a></li>

          <li><a href="#ConvolverNode-section">
          17. The ConvolverNode Interface</a></li>

          <li><a href="#RealtimeAnalyserNode-section">
          18. The RealtimeAnalyserNode Interface</a></li>

          <li><a href="#AudioChannelSplitter-section">
          19. The AudioChannelSplitter Interface</a></li>

          <li><a href="#AudioChannelMerger-section">
          20. The AudioChannelMerger Interface</a></li>







      
          <li><a href="#AudioElementIntegration-section">
          21. Integration with the <code>audio</code> and <code>video</code> element</a></li>

          <li><a href="#MixerGainStructure-section">
          22. Mixer Gain Structure</a></li>



          <li><a href="#ChannelLayouts-section">
          23. Channel Layouts</a></li>

          <li><a href="#UpMix-section">
          24. Channel up-mixing and down-mixing</a></li>





          <li><a href="#EventScheduling-section">
          25. Event Scheduling</a></li>

          <li><a href="#Spatialization-section">
          26. Spatialization / Panning</a></li>

          <li><a href="#Convolution-section">
          27. Linear Effects using Convolution</a></li>

          <li><a href="#JavaScriptProcessing-section">
          28. JavaScript Synthesis and Processing</a></li>

          <li><a href="#RealtimeAnalysis-section">
          29. Realtime Analysis</a></li>

          <li><a href="#Performance-section">
          30. Performance Considerations</a></li>
            
          <li><a href="#ExampleApplications-section">
          31. Example Applications</a></li>
      
          <li><a href="#SecurityConsiderations-section">
          32. Security Considerations</a></li>
      
          <li><a href="#requirements">
          33. Requirements and Use Cases</a></li>

          <li><a href="#ChangeLog-section">
          34. Change Log</a></li>
      

          </li>
      
      </ul></div> 
    </div> 
 
 

 
 
 
    <div id="sections"> 
    <div id="introduction" class="section"> 
    <h2>1. Introduction</h2> 
 
      <p class="norm">This section is informative.</p> 
 
    <p> 
      Audio on the web has been fairly primitive up to this point and until very recently has had to be delivered through plugins such as Flash and QuickTime.
      The introduction of the <code>audio</code> element in HTML5 is very important, allowing for basic streaming audio playback.
      But, it is not powerful enough to handle more complex audio applications. For sophisticated web-based games or interactive applications, another solution is required.
      It is a goal of this specification to include the capabilities found in modern game audio engines as well as some of the mixing, processing,
      and filtering tasks that are found in modern desktop audio production applications.
      
      <p>
      The APIs have been designed with a wide variety of <a href="#ExampleApplications-section">use cases</a> in mind.
      Ideally, it should be able to support <i>any</i> use case which could reasonably be implemented with an optimized C++ engine controlled via JavaScript and run in a browser.
      That said, modern desktop audio software can have very advanced capabilities, some of which would be difficult or impossible to build with this system.
      Apple's Logic Audio is one such application which has support for external MIDI controllers, arbitrary plugin audio effects and synthesizers,
      highly optimized direct-to-disk audio file reading/writing, tightly integrated time-stretching, and so on.
      Nevertheless, the proposed system will be quite capable of supporting a large range of reasonably complex games and interactive applications, including musical ones.
      And it can be a very good complement to the more advanced graphics features just now being offered by WebGL.
      The API has been designed so that more advanced capabilities can be added at a later time.
      
      </p>
      
      <h2>Features</h2>

      <p>
        The API supports these primary features:
    </p>
      
      <ul>
          <li> <a href="#ModularRouting-section">Modular routing</a> supporting complex mixing/effect architectures, including multiple sends and submixes.</li>
          <li> <a href="#DynamicLifetime">Dynamic creation</a> of audio sources with flexible effect routing</li>          
          <li> Audio stream synthesis and processing <a href="#JavaScriptProcessing-section">directly in JavaScript</a>
          <li> Processing of audio sources from an <a href="#AudioElementIntegration-section"><code>audio</code> element</a>
          <li> <a href="#EventScheduling-section">Sample-accurate scheduled sound playback</a> for musical applications requiring a very high degree of rhythmic precision such as drum machines and sequencers</li>
          <li> <a href="#Spatialization-section">Spatialized audio</a> supporting a wide range of 3D games and immersive environments:

          <ul> 
              <li> Panning models: equal-power, HRTF, sound-field, pass-through, matrix-mix </li> 
              <li> Distance Attenuation </li> 
              <li> Sound Cones </li> 
              <li> Obstruction / Occlusion </li> 
              <li> Doppler Shift </li> 
              <li> Source / Listener based
          </ul> 
          
          <li> A <a href="#Convolution-section">convolution engine</a> for a wide range of linear effects, especially very high-quality room effects.
            Here are some examples of possible effects:</li>
          <ul> 
        		<li> Small / large room </li>
        		<li> Cathedral </li>
        		<li> Concert hall </li>
        		<li> Cave </li>
        		<li> Tunnel </li>
        		<li> Hallway </li>
        		<li> Forest </li>
        		<li> Amphitheater </li>
        		<li> Sound of a distant room through a doorway </li>
        		<li> Extreme filters</li>
        		<li> Strange backwards effects</li>
        		<li> Extreme comb filter effects </li>
          </ul> 
          
          
          <li> Efficient <a href="#RealtimeAnalysis-section">real-time time-domain and frequency analysis / music visualizer support</a></li>
          <li> Efficient biquad filters for lowpass, highpass, and other common filters. </li>
      </ul>

      In addition these features can be supported:
      <ul>
          <li> Dynamics compression for overall control and sweetening of the mix </li>
          <li> A Waveshaping effect for distortion and other non-linear effects</li>
          <li> Automation of audio parameters for envelopes, fade-ins / fade-outs, granular effects, etc. </li>
      </ul>
      
      
      
      </p>
      
      <div id="ModularRouting-section">
      <h2>Modular Routing</h2>

        <p>
        Modular routing allows arbitrary connections between different <a href="#AudioNode-section"><code>AudioNode</code></a> objects.  Each node can have inputs and/or outputs.
        An <a href="#AudioSourceNode-section"><code>AudioSourceNode</code></a> has no inputs and a single output.  An <a href="#AudioDestinationNode-section"><code>AudioDestinationNode</code></a> has one input and no outputs and
        represents the final destination to the audio hardware.  Other nodes such as filters can be placed between
        the <a href="#AudioSourceNode-section"><code>AudioSourceNode</code></a> nodes and the final <a href="#AudioDestinationNode-section"><code>AudioDestinationNode</code></a> node.
        
        The developer doesn't have to worry about low-level stream format details when two objects are connected together; <a href="#UpMix-section">the right thing just happens</a>.
        For example, if a mono audio stream is connected to a stereo input it should just mix to left and right channels <a href="#UpMix-section">appropriately</a>.

        </p>
        <p>
        In the simplest case, a single source can be routed directly to the output.
          All routing occurs within an <a href="#AudioContext-section"><code>AudioContext</code></a> containing a single
        <a href="#AudioDestinationNode-section"><code>AudioDestinationNode</code></a>:
        </p>
        
        <img src="modular-routing1.png"/>

        <p>
            Illustrating this simple routing, here's a simple example playing a single sound:

                    <div class="block"><div class="blockTitleDiv"><span class="blockTitle">ECMAScript</span></div><div class="blockContent"><pre class="code"><code class="es-code"> 

            var context = new AudioContext();

            function playSound() {
                var source = context.createBufferSource();
                source.buffer = dogBarkingBuffer;
                source.connect(context.destination);
                source.noteOn(0);
            }
                    </code></pre></div></div> 


        </p>

        <p>
        Here's a more complex example with three sources and a convolution reverb send with a dynamics compressor at the final output stage:
        </p>
        
        
        <img src="modular-routing2.png"/>
        
        <p>
            ADD JAVASCRIPT EXAMPLE CODE HERE...
        </p>
        
        </div>
        
        
    <div id="DynamicLifetime">
    <h2>Dynamic Lifetime</h2>

      <p>
      In addition to allowing the creation of static routing configurations, it should also be possible to do custom effect routing on dynamically allocated voices which have
      a limited lifetime.  For the purposes of this discussion, let's call these short-lived voices "notes".  Many audio applications incorporate the ideas of notes, examples being drum machines,
      sequencers, and 3D games with many one-shot sounds getting triggered according to game play.
      </p>
      
      <p>
      In a traditional software synthesizer, notes are dynamically allocated and released from a pool of available resources.
      The note is allocated when a MIDI note-on message is received.
      It is released when the note has finished playing either due to it having reached the end of its sample-data (if non-looping),
      it having reached a sustain phase of its envelope which is zero, or due to a MIDI note-off message putting it into the release phase of its envelope.
      In the MIDI note-off case, the note is not released immediately, but only when the release envelope phase has finished. At any given time,
      there can be a large number of notes playing but the set of notes is constantly changing as new notes are added into the routing graph, and old ones are released.
      </p>
      
      <p>
      The audio system automatically deals with tearing-down the part of the routing graph for individual "note" events.
      A "note" is represented by an <code>AudioBufferSourceNode</code>, which can be directly connected to other processing nodes.  When the note has finished playing, the context will automatically
      release the reference to the <code>AudioBufferSourceNode</code>, which in turn will release references to any nodes it is connected to, and so on.  The nodes will automatically get disconnected
      from the graph and will be deleted when they have no more references.  Nodes in the graph which are long-lived and shared between dynamic voices can be managed explicitly.
      Although it sounds complicated, this all happens automatically with no extra JavaScript handling required.
      </p>

        
        Here's an example:
        
        <br><br>
  
        <div class="example"><div class="exampleHeader">Example</div> 
        <img src="dynamic-allocation.png"/>

        <p>The low-pass filter, panner, and second gain nodes are directly connected from the one-shot sound.  So when it has finished playing the context will
         automatically release them (everything within the dotted line).  If there are no longer any JavaScript references to the one-shot sound and connected nodes, then they will be immediately 
         removed from the graph and deleted. The streaming source, has a global reference and will remain connected until it is explicitly disconnected.

        Here's how it might look in JavaScript:
        </p> 
        <div class="block"><div class="blockTitleDiv"><span class="blockTitle">ECMAScript</span></div><div class="blockContent"><pre class="code"><code class="es-code"> 

var context = 0;
var compressor = 0;
var gainNode1 = 0;
var streamingAudio = 0;

<span class="comment">// Initial setup of the "long-lived" part of the routing graph </span> 
function setupAudioContext() {
    context = new AudioContext();

    compressor = context.createCompressor();
    gainNode1 = context.createGainNode();

    streamingAudio = document.getElementById('audioTagID');
    streamingAudio.audioSource.connect(gainNode1);

    gainNode1.connect(compressor);
    compressor.connect(context.destination);
}

<span class="comment">// Later in response to some user action (typically mouse or key event) </span>
<span class="comment">// a one-shot sound can be played. </span>
function playSound() {
    var oneShotSound = context.createBufferSource();
    oneShotSound.buffer = dogBarkingBuffer;

    <span class="comment">// Create a filter, panner, and gain node. </span>
    var lowpass = context.createLowPass2Filter();
    var panner = context.createPanner();
    var gainNode2 = context.createGainNode();
    
    <span class="comment">// Make connections </span>
    oneShotSound.connect(lowpass);
    lowpass.connect(panner);
    panner.connect(gainNode2);
    gainNode2.connect(compressor);

    <span class="comment">// Play 0.75 seconds from now (to play immediately pass in 0.0)</span>
    oneShotSound.noteOn(context.currentTime + 0.75);
}
        </code></pre></div></div> 
        </div> 
        </div> 

    <br>
    <br>
      
      
    </p> 

    <br>
    <br>
    <br>
    <br>
    
 
      <div id="conformance" class="section"> 
        <h2>2. Conformance</h2> 
 
        <p> 
          Everything in this specification is normative except for
          examples and sections marked as being informative.
        </p> 
        <p> 
          The keywords “<span class="rfc2119">MUST</span>”,
          “<span class="rfc2119">MUST NOT</span>”,
          “<span class="rfc2119">REQUIRED</span>”,
          “<span class="rfc2119">SHALL</span>”,
          “<span class="rfc2119">SHALL NOT</span>”,
          “<span class="rfc2119">RECOMMENDED</span>”,
          “<span class="rfc2119">MAY</span>” and
          “<span class="rfc2119">OPTIONAL</span>” in this document are to be
          interpreted as described in
          <cite><a href="http://www.ietf.org/rfc/rfc2119">Key words for use in RFCs to
              Indicate Requirement Levels</a></cite> 
          <a href="#RFC2119">[RFC2119]</a>.
        </p> 
        <p> 
          The following conformance classes are defined by this specification:
        </p> 
        <dl> 
          <dt><dfn id="dfn-conforming-implementation">conforming implementation</dfn></dt> 
          <dd> 
            <p> 
              A user agent is considered to be a
              <a class="dfnref" href="#dfn-conforming-implementation">conforming implementation</a> 
              if it satisfies all of the <span class="rfc2119">MUST</span>-,
              <span class="rfc2119">REQUIRED</span>- and <span class="rfc2119">SHALL</span>-level
              criteria in this specification that apply to implementations.
            </p> 
          </dd>         
        </dl> 
      </div> 
      <div id="terminology" class="section"> 
        <h2>3. Terminology and Algorithms</h2> 
       <p>This specification includes algorithms (steps) as part of the definition of methods.  Conforming implementations (referred to as "user agents" from here on) MAY use other algorithms in the
       implementation of these methods, provided
       the end result is the same.</p> 
      </div> 
 
    <div id="AudioNode-section" class="section"> 
    <h2>4. The AudioNode Interface</h2> 
    <p> 
      AudioNodes are the building blocks of an <a href="#AudioContext-section"><code>AudioContext</code></a>.
      This interface represents audio sources, the audio destination, and intermediate processing modules.
      These modules can be connected together to form <a href="#ModularRouting-section">processing graphs</a> for rendering audio to the audio hardware.
      Each node can have inputs and/or outputs.
      An <a href="#AudioSourceNode-section"><code>AudioSourceNode</code></a> has no inputs and a single output.
      An <a href="#AudioDestinationNode-section"><code>AudioDestinationNode</code></a> has one input and no outputs and
      represents the final destination to the audio hardware.  Most processing nodes such as filters will have one input and one output.
      
      
    </p> 
    <div class="block"><div class="blockTitleDiv"><span class="blockTitle">IDL</span></div><div class="blockContent"><pre class="code"><code class="idl-code"> 

    interface <dfn id="dfn-AudioNode">AudioNode</dfn> {

        void connect(in AudioNode destination, in unsigned long output = 0, in unsigned long input = 0);
        void disconnect(in int output = 0);
        readonly attribute unsigned long numberOfInputs;
        readonly attribute unsigned long numberOfOutputs;

    }
    </code></pre></div></div> 


    <div id="attributes-AudioNode" class="section"> 
    <h3>4.1. Attributes</h3> 
    <dl><dt id="dfn-numberOfInputs"><code>numberOfInputs</code></dt><dd><p>The number of inputs feeding into the AudioNode.  This will be 0 for an AudioSourceNode.</p></dd></dl> 
    <dl><dt id="dfn-numberOfOutputs"><code>numberOfOutputs</code></dt><dd><p>The number of outputs coming out of the AudioNode.  This will be 0 for an AudioDestinationNode.</p></dd></dl> 
    </div>
    
    <div id="methodsandparams-AudioNode" class="section"> 
    <h3>4.2. Methods and Parameters</h3> 
    <dl><dt id="dfn-connect">The <code>connect</code> method</dt> 
    <dd>
    <p>Connects the AudioNode to another AudioNode.</p> 
    <p>The <dfn id="dfn-destination">destination</dfn> parameter is the AudioNode to connect to.</p> 
    <p>The <dfn id="dfn-output">output</dfn> parameter is an index describing which output of the AudioNode from which to connect. An out-of-bound value throws an exception.</p>
    <p>The <dfn id="dfn-input">input</dfn> parameter is an index describing which input of the destination AudioNode to connect to.  An out-of-bound value throws an exception. </p>
      
    </dd></dl> 

    <dl><dt id="dfn-disconnect">The <code>disconnect</code> method</dt> 
    <dd>
    <p>Disconnects an AudioNode's output.</p> 
    <p>The <dfn id="dfn-output">output</dfn> parameter is an index describing which output of the AudioNode to disconnect. </p>
      
    </dd></dl> 

  </div> 



  <div id="AudioContext-section" class="section"> 
    <h2>5. The AudioContext Interface</h2> 
    <p> 
      This interface represents a set of <a href="#AudioNode-section"><code>AudioNode</code></a> objects and their connections.
        It allows for arbitrary routing of signals to the <a href="#AudioDestinationNode-section"><code>AudioDestinationNode</code></a>
       (what the user ultimately hears).
      Nodes are created from the context and are then <a href="#ModularRouting-section">connected</a> together.  In a basic implementation, only a single AudioContext
      will be allowed per document.  An AudioContext is constructed as follows:
    </p> 

    <pre>
    var context = new AudioContext();
    </pre>
    
    <br>

    <div class="block"><div class="blockTitleDiv"><span class="blockTitle">IDL</span></div><div class="blockContent"><pre class="code"><code class="idl-code"> 

    interface <dfn id="dfn-AudioContext">AudioContext</dfn> {

        readonly attribute AudioDestinationNode destination;
        readonly attribute float sampleRate;
        readonly attribute float currentTime;
        readonly attribute AudioListener listener;

        AudioBuffer createBuffer(in unsigned long numberOfChannels, in unsigned long length, in float sampleRate);
        
        <span class="comment">// AudioNode creation </span>         
        AudioBufferSourceNode createBufferSource();
        AudioGainNode createGainNode();
        DelayNode createDelayNode();
        LowPass2FilterNode createLowPass2Filter();
        HighPass2FilterNode createHighPass2Filter();
        AudioPannerNode createPanner();
        ConvolverNode createConvolver();
        AudioChannelSplitter createChannelSplitter();
        AudioChannelMerger createChannelMerger();
        <span class="comment">// and so on... </span>         

    }
    </code></pre></div></div> 


    <div id="attributes-AudioContext" class="section">
    <h3>5.1. Attributes</h3> 
    <dl><dt id="dfn-destination"><code>destination</code></dt><dd><p>An <a href="#AudioDestinationNode-section"><code>AudioDestinationNode</code></a> with a single input representing the final destination for all audio
     (to be rendered to the audio hardware).  All AudioNodes actively rendering audio will directly or indirectly connect to <code>destination</code>.</p></dd></dl> 
     <dl><dt id="dfn-sampleRate"><code>sampleRate</code></dt><dd><p>The sample rate (in sample-frames per second)
      at which the AudioContext handles audio (all AudioNodes in the context).
     It is assumed in this simplified model that sample-rate converters or "varispeed" processors are not supported in real-time processing.</p></dd></dl> 
     <dl><dt id="dfn-currentTime"><code>currentTime</code></dt><dd><p>This is a time in seconds which starts at zero when the context is created and increases in real-time.
     All scheduled times are relative to it. This is not a "transport" time which can be started, paused, and re-positioned.
     It is always moving forward.  A GarageBand-like timeline transport system can be very easily built
     on top of this (in JavaScript).  This time corresponds to an ever-increasing hardware timestamp.
     </p></dd></dl> 
    <dl><dt id="dfn-listener"><code>listener</code></dt><dd><p>An <a href="#AudioListener-section"><code>AudioListener</code></a> which is used for 3D <a href="#Spatialization-section">spatialization</a>.</p></dd></dl> 
    </div> 

    <div id="methodsandparams-AudioContext" class="section"> 
    <h3>5.2. Methods and Parameters</h3> 

    <dl><dt id="dfn-createBuffer">The <code>createBuffer</code> method</dt> 
    <dd>
    <p>Creates an AudioBuffer of the given size.  The audio data in the buffer will be zero-initialized (silent).</p> 

    <p>The <dfn id="dfn-numberOfChannels">numberOfChannels</dfn> parameter determines how many channels the buffer will have. </p>
    <p>The <dfn id="dfn-length">length</dfn> parameter determines the size of the buffer in sample-frames. </p>
    <p>The <dfn id="dfn-sampleRate">sampleRate</dfn> parameter describes the sample-rate of the linear PCM audio data in the buffer in sample-frames per second. </p>

    </dd>
    

    <dl><dt id="dfn-createBufferSource">The <code>createBufferSource</code> method</dt> 
    <dd>
    <p>Creates an <a href="#AudioBufferSourceNode-section"><code>AudioBufferSourceNode</code></a>.</p> 
    </dd>

    <dl><dt id="dfn-createGainNode">The <code>createGainNode</code> method</dt> 
    <dd>
    <p>Creates an <a href="#AudioGainNode-section"><code>AudioGainNode</code></a>.</p> 
    </dd>
    
    <dl><dt id="dfn-createDelayNode">The <code>createDelayNode</code> method</dt> 
    <dd>
    <p>Creates a <a href="#DelayNode-section"><code>DelayNode</code></a> representing a variable delay line.  The initial default delay time will be 0 seconds.</p> 
    </dd>
    
    <dl><dt id="dfn-createLowPass2Filter">The <code>createLowPass2Filter</code> method</dt> 
    <dd>
    <p>Creates a <a href="#LowPass2FilterNode-section"><code>LowPass2FilterNode</code></a> representing a two-pole resonant low-pass filter.</p> 
    </dd>
    
    <dl><dt id="dfn-createHighPass2Filter">The <code>createHighPass2Filter</code> method</dt> 
    <dd>
    <p>Creates a <a href="#HighPass2FilterNode-section"><code>HighPass2FilterNode</code></a> representing a two-pole resonant high-pass filter.</p> 
    </dd>

    <dl><dt id="dfn-createPanner">The <code>createPanner</code> method</dt> 
    <dd>
    <p>Creates an <a href="#AudioPannerNode-section"><code>AudioPannerNode</code></a>.</p> 
    </dd>
    
    <dl><dt id="dfn-createConvolver">The <code>createConvolver</code> method</dt> 
    <dd>
    <p>Creates a <a href="#ConvolverNode-section"><code>ConvolverNode</code></a>.</p> 
    </dd>

    <dl><dt id="dfn-createChannelSplitter">The <code>createChannelSplitter</code> method</dt>
    <dd>
    <p>Creates an <a href="#AudioChannelSplitter-section"><code>AudioChannelSplitter</code></a> representing a channel splitter.</p> 
    </dd>
    
    <dl><dt id="dfn-createChannelMerger">The <code>createChannelMerger</code> method</dt>
    <dd>
    <p>Creates an <a href="#AudioChannelMerger-section"><code>AudioChannelMerger</code></a> representing a channel merger.</p> 
    </dd>
    

    </dd></dl> 
  </div> 
  


    <div id="AudioSourceNode-section" class="section"> 
    <h2>6. The AudioSourceNode Interface</h2> 
    <p> 
      This is an abstract interface representing an audio source, an <a href="#AudioNode-section"><code>AudioNode</code></a> which has no inputs and a single output:
    </p>  
      <pre>
      numberOfInputs == 0
      numberOfOutputs == 1
      </pre>

      <p>
      Subclasses of AudioSourceNode will implement specific types of audio sources.
      </p>

    <div class="block"><div class="blockTitleDiv"><span class="blockTitle">IDL</span></div><div class="blockContent"><pre class="code"><code class="idl-code"> 

    interface <dfn id="dfn-AudioSourceNode">AudioSourceNode</dfn> : AudioNode {

    }
    </code></pre></div></div> 

  </div> 

  


    <div id="AudioDestinationNode-section" class="section"> 
    <h2>7. The AudioDestinationNode Interface</h2> 
    <p>
      This is an <a href="#AudioNode-section"><code>AudioNode</code></a> representing the final audio destination and is what the user will ultimately hear.
      It can be considered as an audio output device which is connected to speakers.
      All rendered audio to be heard will be routed to this node, a "terminal" node in the AudioContext's routing graph.  There is only a single AudioDestinationNode
      per AudioContext, provided through the <code>destination</code> attribute of <a href="#AudioContext-section"><code>AudioContext</code></a>.
    </p>  
      <pre>
      numberOfInputs == 1
      numberOfOutputs == 0
      </pre>

    <div class="block"><div class="blockTitleDiv"><span class="blockTitle">IDL</span></div><div class="blockContent"><pre class="code"><code class="idl-code"> 

    interface <dfn id="dfn-AudioDestinationNode">AudioDestinationNode</dfn> : AudioNode {

    }
    </code></pre></div></div> 

  </div> 

  



  
  
  <div id="AudioParam-section" class="section"> 
    <h2>8. The AudioParam Interface</h2> 
    <p> 
      This interface controls an individual aspect of an <a href="#AudioNode-section"><code>AudioNode</code></a>'s functioning, such as volume.
      
      
    </p> 
    <div class="block"><div class="blockTitleDiv"><span class="blockTitle">IDL</span></div><div class="blockContent"><pre class="code"><code class="idl-code"> 

    interface <dfn id="dfn-AudioParam">AudioParam</dfn> {

        attribute float value;
        readonly attribute float minValue;
        readonly attribute float maxValue;
        readonly attribute float defaultValue;

        readonly attribute DOMString name;

        <span class="comment">// Should define units constants here (seconds, decibels, cents, etc.) </span>         
        
        readonly attribute short units;

        <span class="comment">// An advanced implementation could include automation: </span>         
        <span class="comment">// Can be piecewise linear, or sample-accurate buffer for envelopes, </span>         
        <span class="comment">// volume fade-outs, LFOs, grain windows, etc. </span>         
        AudioCurve automation;

    }
    </code></pre></div></div> 


    <div id="attributes-AudioParam" class="section"> 
    <h3>8.1. Attributes</h3> 
    <dl><dt id="dfn-value"><code>value</code></dt><dd><p>The parameter's floating-point value.  If a value is set outside the allowable range described by
    <code>minValue</code> and <code>maxValue</code> an exception is thrown.   </p></dd></dl> 
    <dl><dt id="dfn-minValue"><code>minValue</code></dt><dd><p>Minimum value.  The <code>value</code> attribute must not be set lower than this value.</p></dd></dl> 
    <dl><dt id="dfn-maxValue"><code>maxValue</code></dt><dd><p>Maximum value.  The <code>value</code> attribute must be set lower than this value. </p></dd></dl> 
    <dl><dt id="dfn-defaultValue"><code>defaultValue</code></dt><dd><p>Initial value for the value attribute</p></dd></dl> 
    <dl><dt id="dfn-name"><code>name</code></dt><dd><p>The name of the parameter.</p></dd></dl> 
    <dl><dt id="dfn-units"><code>units</code></dt><dd><p>Represents the type of value (seconds, decibels, cents, etc.).</p></dd></dl> 
    <dl><dt id="dfn-automation"><code>automation</code></dt><dd><p>An AudioCurve which can automate the parameter value over time.</p></dd></dl> 
    </div> 


  </div> 








  <div id="AudioGain-section" class="section"> 
  <h3>9. AudioGain</h3> 

  <p> 
    This interface is a particular type of <code>AudioParam</code> which specifically controls the gain (volume) of some aspect of the audio processing.
    The unit type is "linear gain".  The <code>minValue</code> is 0.0, and although the nominal <code>maxValue</code> is 1.0, higher values are allowed
    (no exception thrown).
    
    
  </p> 
  <div class="block"><div class="blockTitleDiv"><span class="blockTitle">IDL</span></div><div class="blockContent"><pre class="code"><code class="idl-code"> 

  interface <dfn id="dfn-AudioGain">AudioGain</dfn> : AudioParam {

  };
  </code></pre></div></div> 

  </div>
  
  
  
  

  <div id="AudioGainNode-section" class="section"> 

    <h2>10. The AudioGainNode Interface</h2> 
    <p> 
      Changing the gain of an audio signal is a fundamental operation in audio applications.  This interface is an AudioNode with a single input and single output:
    </p>
    
    <pre>
    numberOfInputs == 1
    numberOfOutputs == 1
    </pre>
    
    <p>
     which changes the gain of (scales) the incoming audio signal by a certain amount.
       The default amount is 1.0 (no gain change).
     The <code>AudioGainNode</code> is one of the building blocks for creating <a href="#MixerGainStructure-section">mixers</a>.
     The implementation must make gain changes to the audio stream smoothly, without introducing noticeable clicks or glitches.  This process is called "de-zippering".
      
    </p> 
    <div class="block"><div class="blockTitleDiv"><span class="blockTitle">IDL</span></div><div class="blockContent"><pre class="code"><code class="idl-code"> 

    interface <dfn id="dfn-AudioGainNode">AudioGainNode</dfn> : AudioNode {

        AudioGain gain;

    }
    </code></pre></div></div> 


    <div id="attributes-AudioGainNode" class="section"> 
    <h3>10.1. Attributes</h3> 
    <dl><dt id="dfn-gain"><code>gain</code></dt><dd><p>An AudioGain object representing the amount of gain to apply.  The default value
    (<code>gain.value</code>) is 1.0 (no gain change).  See <a href="#AudioGain-section"><code>AudioGain</code></a> for more information. </p></dd></dl> 
    </div> 

  </div> 


  <div id="DelayNode-section" class="section"> 

    <h2>11. The DelayNode Interface</h2> 
    <p> 
      A delay-line is a fundamental building block in audio applications.  This interface is an AudioNode with a single input and single output:
    </p>
    
    <pre>
    numberOfInputs == 1
    numberOfOutputs == 1
    </pre>
    
    <p>
     which delays the incoming audio signal by a certain amount.  The default amount is 0.0 seconds (no delay).
     When the delay time is changed, the implementation must make the transition smoothly,without introducing noticeable clicks or glitches to the audio stream.
      
    </p> 
    <div class="block"><div class="blockTitleDiv"><span class="blockTitle">IDL</span></div><div class="blockContent"><pre class="code"><code class="idl-code"> 

    interface <dfn id="dfn-DelayNode">DelayNode</dfn> : AudioNode {

        AudioParam delayTime;

    }
    </code></pre></div></div> 


    <div id="attributes-AudioGainNode" class="section"> 
    <h3>11.1. Attributes</h3> 
    <dl><dt id="dfn-delayTime"><code>delayTime</code></dt><dd><p>An AudioParam object representing the amount of delay (in seconds) to apply.  The default value
    (<code>delayTime.value</code>) is 0.0 (no delay).  The minimum value is 0.0 and the maximum value is currently 1.0 (but this is arbitrary and could be increased).</p></dd></dl> 
    </div> 

  </div> 











  <div id="AudioBuffer-section" class="section"> 
    <h2>12. The AudioBuffer Interface</h2> 
    <p> 
      This interface represents a memory-resident audio asset (for one-shot sounds and other short audio clips).  
      Its format is non-interleaved linear PCM with a nominal range of -1.0 -> +1.0.  It can contain one or more channels.
      It is analogous to a WebGL texture.  Typically, it would be expected that the length of the PCM data would be fairly short (usually somewhat less than a minute).  For longer
      sounds, such as music soundtracks, streaming should be used with the <code>audio</code> element and <code>MediaElementAudioSourceNode</code>.
      
    </p> 
    <div class="block"><div class="blockTitleDiv"><span class="blockTitle">IDL</span></div><div class="blockContent"><pre class="code"><code class="idl-code"> 

    interface <dfn id="dfn-AudioBuffer">AudioBuffer</dfn> {

        <span class="comment">// linear gain (default 1.0) </span>         
        attribute AudioGain gain;
        
        readonly attribute float sampleRate;
        readonly attribute float length;

        <span class="comment">// in seconds </span>         
        readonly attribute float duration;  

        readonly attribute int numberOfChannels;

        Float32Array getChannelData(in unsigned long channel);

    }
    </code></pre></div></div> 


    <div id="attributes-AudioBuffer" class="section"> 
    <h3>12.1. Attributes</h3> 
    <dl><dt id="dfn-gain"><code>gain</code></dt><dd><p>The amount of gain to apply when using this buffer in any <code>AudioBufferSourceNode</code>.  The default value is 1.0. </p></dd></dl> 
    <dl><dt id="dfn-sampleRate"><code>sampleRate</code></dt><dd><p>The sample-rate for the PCM audio data in samples per second.</p></dd></dl> 
    <dl><dt id="dfn-length"><code>length</code></dt><dd><p>Length of the PCM audio data in sample-frames.</p></dd></dl> 
    <dl><dt id="dfn-duration"><code>duration</code></dt><dd><p>Duration of the PCM audio data in seconds.</p></dd></dl> 
    <dl><dt id="dfn-numberOfChannels"><code>numberOfChannels</code></dt><dd><p>The number of discrete audio channels.</p></dd></dl> 
    </div> 

    <div id="methodsandparams-AudioBuffer" class="section"> 
    <h3>12.2. Methods and Parameters</h3> 

    <dl><dt id="dfn-getChannelData">The <code>getChannelData</code> method</dt> 
    <dd>
    <p>Gets direct access to the audio data stored in an AudioBuffer.</p> 
    <p>The <dfn id="dfn-channel">channel</dfn> parameter is an index representing the particular channel to get data for. </p>
    </dd>
    </div>


  </div> 





  <div id="AudioBufferSourceNode-section" class="section"> 

    <h2>13. The AudioBufferSourceNode Interface</h2> 
    <p> 
      This interface represents an audio source from an in-memory audio asset in an <code>AudioBuffer</code>.  It generally will be used for short audio assets 
      which require a high degree of scheduling flexibility (can playback in rhythmically perfect ways).      
    </p>
    
    <pre>
    numberOfInputs == 0
    numberOfOutputs == 1
    </pre>
    
    <div class="block"><div class="blockTitleDiv"><span class="blockTitle">IDL</span></div><div class="blockContent"><pre class="code"><code class="idl-code"> 

    interface <dfn id="dfn-AudioBufferSourceNode">AudioBufferSourceNode</dfn> : AudioSourceNode {

        <span class="comment">// Playback this in-memory audio asset  </span>   
        <span class="comment">// Many sources can share the same buffer  </span>   
        attribute AudioBuffer buffer;

        attribute boolean loop;

        void noteOn(in float when);
        void noteGrainOn(in float when, in float grainOffset, in float grainDuration);
        void noteOff(in float when);

    }
    </code></pre></div></div>


    <div id="attributes-AudioBufferSourceNode" class="section"> 
    <h3>13.1. Attributes</h3> 
    <dl><dt id="dfn-buffer"><code>buffer</code></dt><dd><p>Represents the audio asset to be played. </p></dd></dl> 
    <dl><dt id="dfn-loop"><code>loop</code></dt><dd><p>Indicates if the audio data should play in a loop. </p></dd></dl> 
    </div> 

  </div> 


  <div id="methodsandparams-AudioBufferSourceNode" class="section"> 
  <h3>13.2. Methods and Parameters</h3> 
  <dl><dt id="dfn-noteOn">The <code>noteOn</code> method</dt> 
  <dd>
  <p>Schedules a sound to playback at an exact time.</p> 
  <p>The <dfn id="dfn-when">when</dfn> parameter describes at what time (in seconds) the sound should start playing.
  This time is relative to the <b>currentTime</b> attribute of the AudioContext.  If 0 is passed in for this value or if the
  value is less than <b>currentTime</b>, then the sound will start playing immediately.
  </p> 
  </dd>

  <dl><dt id="dfn-noteGrainOn">The <code>noteGrainOn</code> method</dt> 
  <dd>
  <p>Schedules a portion of a sound to playback at an exact time.  A "grain window" will be applied to the portion of the sound within the buffer,
    smoothly fading in and out.</p> 
  <p>The <dfn id="dfn-when">when</dfn> parameter describes at what time (in seconds) the sound should start playing.
  This time is relative to the <b>currentTime</b> attribute of the AudioContext.  If 0 is passed in for this value or if the
  value is less than <b>currentTime</b>, then the sound will start playing immediately.
  </p> 

  <p>The <dfn id="dfn-grainOffset">grainOffset</dfn> parameter describes the offset in the buffer (in seconds) for the portion to be played.  </p> 
  <p>The <dfn id="dfn-grainDuration">grainDuration</dfn> parameter describes the duration of the portion (in seconds) to be played.  </p>
  </dd>

  <dl><dt id="dfn-noteOff">The <code>noteOff</code> method</dt> 
  <dd>
  <p>Schedules a sound to stop playback at an exact time.  In an advanced implementation, the sound may not stop playing back immediately but
    would instead enter the "release" portion of its envelope.</p> 
  <p>The <dfn id="dfn-when">when</dfn> parameter describes at what time (in seconds) the sound should stop playing.
  This time is relative to the <b>currentTime</b> attribute of the AudioContext.  If 0 is passed in for this value or if the
  value is less than <b>currentTime</b>, then the sound will stop playing immediately.
  </p> 
  </dd>
    
    
  </dd></dl> 





  <div id="MediaElementAudioSourceNode-section" class="section"> 

    <h2>14. The MediaElementAudioSourceNode Interface</h2> 
    <p> 
      This interface represents an audio source from an <code>audio</code> or <code>video</code> element.  The element's <code>audioSource</code> attribute implements this.      
    </p>
    
    <pre>
    numberOfInputs == 0
    numberOfOutputs == 1
    </pre>
    
    <div class="block"><div class="blockTitleDiv"><span class="blockTitle">IDL</span></div><div class="blockContent"><pre class="code"><code class="idl-code"> 

    interface <dfn id="dfn-MediaElementAudioSourceNode">MediaElementAudioSourceNode</dfn> : AudioSourceNode {

        <span class="comment">// this would map to "playbackRate" attribute of &lt;audio&gt;  </span>       
        attribute AudioParam playbackRate;

    }
    </code></pre></div></div> 


    <div id="attributes-MediaElementAudioSourceNode" class="section"> 
    <h3>14.1. Attributes</h3> 
    <dl><dt id="dfn-playbackRate"><code>playbackRate</code></dt><dd><p>The speed at which to render the audio stream.  The default value is 1.0. </p></dd></dl> 
    </div> 

  </div> 








  <div id="AudioPannerNode-section" class="section"> 

    <h2>15. The AudioPannerNode Interface</h2> 
    <p> 
      This interface represents a processing node which <a href="#Spatialization-section">positions / spatializes</a> an incoming audio stream in three-dimensional space.
      The spatialization is in relation the the <a href="#AudioContext-section"><code>AudioContext</code></a>'s <a href="#AudioListener-section"><code>AudioListener</code></a> (<code>listener</code> attribute).      
    </p>
    
    <pre>
    numberOfInputs == 1
    numberOfOutputs == 1
    </pre>
    

    <div class="block"><div class="blockTitleDiv"><span class="blockTitle">IDL</span></div><div class="blockContent"><pre class="code"><code class="idl-code"> 

    interface <dfn id="dfn-AudioPannerNode">AudioPannerNode</dfn> : AudioNode {

        <span class="comment">// Panning is relative to this listener  </span>         
        attribute AudioListener listener;

        <span class="comment">// Panning model </span>         
        const unsigned short PASSTHROUGH = 0;
        const unsigned short EQUALPOWER = 1;
        const unsigned short HRTF = 2;
        const unsigned short SOUNDFIELD = 3;
        const unsigned short MATRIXMIX = 4;

        <span class="comment">// Default for stereo is HRTF </span>
        attribute long panningModel;

        <span class="comment">// Uses a 3D cartesian coordinate system </span>
        void setPosition(in float x, in float y, in float z);
        void setOrientation(in float x, in float y, in float z);
        void setVelocity(in float x, in float y, in float z);

        <span class="comment">// Distance model and attributes </span>         
        attribute short distanceModel;
        attribute float refDistance;
        attribute float maxDistance;
        attribute float rolloffFactor;

        <span class="comment">// Directional sound cone </span>         
        attribute float coneInnerAngle;
        attribute float coneOuterAngle;
        attribute float coneOuterGain;

        <span class="comment">// Dynamically calculated value </span>         
        readonly attribute AudioGain coneGain;
        readonly attribute AudioGain distanceGain;

    };
    </code></pre></div></div> 


  </div> 

  <div id="attributes-AudioPannerNode" class="section"> 
  <h3>15.1. Constants</h3> 

  <dl><dt id="dfn-PASSTHROUGH"><code>PASSTHROUGH</code></dt><dd><p>An algorithm which passes the incoming audio unchanged to the output (no processing occurs). </p></dd></dl> 
  <dl><dt id="dfn-EQUALPOWER"><code>EQUALPOWER</code></dt><dd><p>A simple and efficient spatialization algorithm using equal-power panning. </p></dd></dl> 
  <dl><dt id="dfn-HRTF"><code>HRTF</code></dt><dd><p>A higher quality spatialization algorithm using a convolution with measured impulse responses from human subjects.
  This panning method renders stereo output. </p></dd></dl> 
  <dl><dt id="dfn-SOUNDFIELD"><code>SOUNDFIELD</code></dt><dd><p>An algorithm which spatializes multi-channel audio using sound field algorithms. </p></dd></dl> 
  <dl><dt id="dfn-MATRIXMIX"><code>MATRIXMIX</code></dt><dd><p>An algorithm where <b>N</b> input channels are spatialized to <b>M</b> output channels according to
  a matrix of weighting coefficients. </p></dd></dl> 

  </div> 



  <div id="attributes-AudioPannerNode" class="section"> 
  <h3>15.2. Attributes</h3> 
  <dl><dt id="dfn-listener"><code>listener</code></dt><dd><p>Represents the <b>listener</b> whose position and orientation is used together with
  the panner's position and orientation to determine how the audio will be spatialized. </p></dd></dl> 

  <dl><dt id="dfn-panningModel"><code>panningModel</code></dt><dd><p>Determines which spatialization algorithm  will be used to position the audio in 3D space.  See the <b>constants</b>
  for the available choices.  The default is <b>HRTF</b>. </p></dd></dl> 

  <dl><dt id="dfn-distanceModel"><code>distanceModel</code></dt><dd><p>Determines which algorithm will be used to reduce the volume of an audio source as it moves away from the
    listener.  TODO: add constants </p></dd></dl> 


  <dl><dt id="dfn-refDistance"><code>refDistance</code></dt><dd><p>A reference distance for reducing volume as source move further from the listener. </p></dd></dl> 
  <dl><dt id="dfn-maxDistance"><code>maxDistance</code></dt><dd><p>The maximum distance between source and listener, after which the volume will not be reduced any further. </p></dd></dl> 
  <dl><dt id="dfn-rolloffFactor"><code>rolloffFactor</code></dt><dd><p>Describes how quickly the volume is reduced as source moves away from listener. </p></dd></dl> 

  <dl><dt id="dfn-coneInnerAngle"><code>coneInnerAngle</code></dt><dd><p>A parameter for directional audio sources, this is an angle, inside of which there will be no volume reduction. </p></dd></dl> 
  <dl><dt id="dfn-coneOuterAngle"><code>coneOuterAngle</code></dt><dd><p>A parameter for directional audio sources, this is an angle, outside of which the volume will be
    reduced to a constant value of <b>coneOuterGain</b>. </p></dd></dl> 

  <dl><dt id="dfn-coneOuterGain"><code>coneOuterGain</code></dt><dd><p>A parameter for directional audio sources, this is the amount of volume reduction outside of
  the <b>coneOuterAngle</b>. </p></dd></dl> 

  </div> 


  <h3>15.3. Methods and Parameters</h3> 
  <dl><dt id="dfn-setPosition">The <code>setPosition</code> method</dt> 
  <dd>
  <p>Sets the position of the audio source relative to the <b>listener</b> attribute.  A 3D cartesian coordinate system is used.</p> 
  <p>The <dfn id="dfn-x">x, y, z</dfn> parameters represent the coordinates in 3D space.  </p> 
  </dd>

  <dl><dt id="dfn-setOrientation">The <code>setOrientation</code> method</dt> 
  <dd>
  <p>Describes which direction the audio source is pointing in the 3D cartesian coordinate space.  Depending on how directional the sound is (controlled by the <b>cone</b> attributes),
    a sound pointing away from the listener can be very quiet or completely silent.</p> 
    <p>The <dfn id="dfn-x">x, y, z</dfn> parameters represent a direction vector in 3D space.  </p> 
  </dd>

  <dl><dt id="dfn-setVelocity">The <code>setVelocity</code> method</dt> 
  <dd>
  <p>Sets the velocity vector of the audio source.  This vector controls both the direction of travel and the speed in 3D space.
  This velocity relative to the listener's velocity is used to determine how much doppler shift (pitch change) to apply.</p> 
  <p>The <dfn id="dfn-x">x, y, z</dfn> parameters describe a direction vector indicating direction of travel and intensity.  </p> 
  </dd>


  </dd></dl> 





  <div id="AudioListener-section" class="section"> 

    <h2>16. The AudioListener Interface</h2> 
    <p> 
      This interface represents the position and orientation of the person listening to the audio scene.  All <a href="#AudioPannerNode-section"><code>AudioPannerNode</code></a>
      objects spatialize in relation to the AudioContext's <code>listener</code>.
      
      See <a href="#Spatialization-section">this</a> section
      for more details about spatialization.
      
    </p> 
    <div class="block"><div class="blockTitleDiv"><span class="blockTitle">IDL</span></div><div class="blockContent"><pre class="code"><code class="idl-code"> 

    interface <dfn id="dfn-AudioListener">AudioListener</dfn> {

        <span class="comment">// linear gain (default 1.0) </span>         
        attribute float gain;

        <span class="comment">// same as OpenAL (default 1.0) </span>         
        attribute float dopplerFactor;

        <span class="comment">// in meters / second (default 343.3) </span>         
        attribute float speedOfSound;

        <span class="comment">// Uses a 3D cartesian coordinate system </span>
        void setPosition(in float x, in float y, in float z);
        void setOrientation(in float x, in float y, in float z, in float xUp, in float yUp, in float zUp);
        void setVelocity(in float x, in float y, in float z);

    };
    </code></pre></div></div> 


  </div> 


  <div id="attributes-AudioListener" class="section"> 
  <h3>16.1. Attributes</h3> 
  <dl><dt id="dfn-gain"><code>gain</code></dt><dd><p>A linear gain used in conjunction with <a href="#AudioPannerNode-section"><code>AudioPannerNode</code></a> objects when spatializing. </p></dd></dl> 

  <dl><dt id="dfn-dopplerFactor"><code>dopplerFactor</code></dt><dd><p>A constant used to determine the amount of pitch shift to use when rendering a doppler effect. </p></dd></dl> 
  <dl><dt id="dfn-speedOfSound"><code>speedOfSound</code></dt><dd><p>The speed of sound used for calculating doppler shift.  The default value is 343.3 meters / second. </p></dd></dl> 

  </div> 


  <h3>16.2. Methods and Parameters</h3> 
  <dl><dt id="dfn-setPosition">The <code>setPosition</code> method</dt> 
  <dd>
  <p>Sets the position of the listener in a 3D cartesian coordinate space.  <code>AudioPannerNode</code> objects use this position relative to individual audio sources for spatialization.</p> 
  <p>The <dfn id="dfn-x">x, y, z</dfn> parameters represent the coordinates in 3D space.  </p> 
  </dd>

  <dl><dt id="dfn-setOrientation">The <code>setOrientation</code> method</dt> 
  <dd>
  <p>Describes which direction the listener is pointing in the 3D cartesian coordinate space.  Both a <b>front</b> vector and an <b>up</b> vector are provided.</p> 
  <p>The <dfn id="dfn-x">x, y, z</dfn> parameters represent a <b>front</b> direction vector in 3D space.  </p> 
  <p>The <dfn id="dfn-x">xUp, yUp, zUp</dfn> parameters represent an <b>up</b> direction vector in 3D space.  </p> 
  </dd>

  <dl><dt id="dfn-setVelocity">The <code>setVelocity</code> method</dt> 
  <dd>
  <p>Sets the velocity vector of the listener.  This vector controls both the direction of travel and the speed in 3D space.
  This velocity relative an audio source's velocity is used to determine how much doppler shift (pitch change) to apply.</p> 
  <p>The <dfn id="dfn-x">x, y, z</dfn> parameters describe a direction vector indicating direction of travel and intensity.  </p> 
  </dd>


  </dd></dl> 







  <div id="ConvolverNode-section" class="section"> 

    <h2>17. The ConvolverNode Interface</h2> 
    <p> 
      This interface represents a processing node which applies a <a href="#Convolution-section">linear convolution effect</a> given an impulse response.
    </p>
    
    <pre>
    numberOfInputs == 1
    numberOfOutputs == 1
    </pre>
    
    <div class="block"><div class="blockTitleDiv"><span class="blockTitle">IDL</span></div><div class="blockContent"><pre class="code"><code class="idl-code"> 

    interface <dfn id="dfn-ConvolverNode">ConvolverNode</dfn> : AudioNode {

        <span class="comment">// Contains the (possibly multi-channel) impulse response </span>
        attribute AudioBuffer buffer;

        // attribute ImpulseResponse response;

    };
    </code></pre></div></div> 


  </div> 


  <div id="attributes-ConvolverNode" class="section"> 
  <h3>17.1. Attributes</h3> 
  <dl><dt id="dfn-buffer"><code>buffer</code></dt><dd><p>A mono or multi-channel audio buffer containing the impulse response used by the convolver. </p></dd></dl> 

  </div> 




  <div id="RealtimeAnalyserNode-section" class="section"> 

    <h2>18. The RealtimeAnalyserNode Interface</h2> 
    <p> 
      This interface represents a node which is able to provide real-time frequency and time-domain <a href="#RealtimeAnalysis-section">analysis</a> information.
      The audio stream will be passed un-processed from input to output.    

    </p>
    
    <pre>
    numberOfInputs == 1
    numberOfOutputs == 1    <--- it has been suggested to have no outputs here - waiting for people's opinions
    </pre>
    
    <div class="block"><div class="blockTitleDiv"><span class="blockTitle">IDL</span></div><div class="blockContent"><pre class="code"><code class="idl-code"> 

    interface <dfn id="dfn-RealtimeAnalyserNode">RealtimeAnalyserNode</dfn> : AudioNode {

        <span class="comment">// Real-time frequency-domain data </span>        
        void getFloatFrequencyData(in Float32Array array);
        void getByteFrequencyData(in Uint8Array array);

        <span class="comment">// Real-time waveform data </span>        
        void getByteTimeDomainData(in Uint8Array array);

        attribute unsigned long fftSize;
        readonly attribute unsigned long frequencyBinCount;

        attribute float minDecibels;
        attribute float maxDecibels;

        attribute float smoothingTimeConstant;

    };
    </code></pre></div></div> 


  </div> 


  <div id="attributes-ConvolverNode" class="section"> 
  <h3>18.1. Attributes</h3> 
  <dl><dt id="dfn-fftSize"><code>fftSize</code></dt><dd><p>The size of the FFT used for frequency-domain analsis.  This must be a power of two. </p></dd></dl> 
  <dl><dt id="dfn-frequencyBinCount"><code>frequencyBinCount</code></dt><dd><p>Half the FFT size. </p></dd></dl> 
  <dl><dt id="dfn-minDecibels"><code>minDecibels</code></dt><dd><p> The minimum power value in the scaling range for the FFT analysis data 
   for conversion to unsigned byte values.     
   </p></dd></dl> 
  <dl><dt id="dfn-maxDecibels"><code>maxDecibels</code></dt><dd><p> The maximum power value in the scaling range for the FFT analysis data 
      for conversion to unsigned byte values. </p></dd></dl> 
  <dl><dt id="dfn-smoothingTimeConstant"><code>smoothingTimeConstant</code></dt><dd><p> A value from 0.0 -> 1.0 where 0.0 represents no time averaging 
    with the last analysis frame. </p></dd></dl> 

  </div> 


  <h3>18.2. Methods and Parameters</h3> 
  <dl><dt id="dfn-getFloatFrequencyData">The <code>getFloatFrequencyData</code> method</dt> 
  <dd>
  <p>Copies the current frequency data into the passed floating-point array.  If the array has fewer elements than the frequencyBinCount, the excess elements will be dropped.         
  </p> 
  <p>The <dfn id="dfn-array">array</dfn> parameter is where frequency-domain analysis data will be copied. </p> 
  </dd>

  <dl><dt id="dfn-getByteFrequencyData">The <code>getByteFrequencyData</code> method</dt> 
  <dd>
  <p>Copies the current frequency data into the passed unsigned byte array.  If the array has fewer elements than the frequencyBinCount, the excess elements will be dropped.         
  </p> 
  <p>The <dfn id="dfn-array">array</dfn> parameter is where frequency-domain analysis data will be copied. </p> 
  </dd>

  <dl><dt id="dfn-getByteTimeDomainData">The <code>getByteTimeDomainData</code> method</dt> 
  <dd>
  <p>Copies the current time-domain (waveform) data into the passed unsigned byte array.  If the array has fewer elements than the frequencyBinCount, the excess elements will be dropped.         
  </p> 
  <p>The <dfn id="dfn-array">array</dfn> parameter is where time-domain analysis data will be copied. </p> 
  </dd>

    
  </dd></dl> 









  <div id="AudioChannelSplitter-section" class="section"> 

    <h2>19. The AudioChannelSplitter Interface</h2> 
    <p>
      The <code>AudioChannelSplitter</code> is for use in more advanced applications and would often be used in conjunction with
       <a href="#AudioChannelMerger-section"><code>AudioChannelMerger</code></a>.
    </p>

    <p>
      This interface represents an AudioNode for accessing the individual channels of an audio stream in the routing graph.
      It has a single input, and a number of "active" outputs which equals the number of channels in the input audio stream.  For example, if a stereo
      input is connected to an <code>AudioChannelSplitter</code> then the number of active outputs will be two (one from the left channel and one from the right).
      There are always a total number of 6 outputs,
      supporting up to 5.1 output (note: this upper limit of 6 is arbitrary and could be increased to support 7.2, and higher).  Any outputs which are not "active" will
      output silence and would typically not be connected to anything.
    </p>
    
    <p>
    One application for <code>AudioChannelSplitter</code> is for doing "matrix mixing" where individual gain control of each channel is desired.
    </p>
    
    <pre>
    numberOfInputs == 1
    numberOfOutputs == 6 // number of "active" (non-silent) outputs is determined by number of channels in the input
    </pre>
    
    <div class="block"><div class="blockTitleDiv"><span class="blockTitle">IDL</span></div><div class="blockContent"><pre class="code"><code class="idl-code"> 

    interface <dfn id="dfn-AudioChannelSplitter">AudioChannelSplitter</dfn> : AudioNode {

    };
    </code></pre></div></div>

  </div> 


  <div id="AudioChannelMerger-section" class="section"> 

    <h2>20. The AudioChannelMerger Interface</h2> 
    <p>
      The <code>AudioChannelMerger</code> is for use in more advanced applications and would often be used in conjunction with
       <a href="#AudioChannelSplitter-section"><code>AudioChannelSplitter</code></a>.
    </p>
    
    <p>
      This interface represents an AudioNode for combining channels from multiple audio streams into a single audio stream.
      It has 6 inputs, but not all of them need be connected.  There is a single output whose audio stream has a number of channels
      equal to the sum of the numbers of channels of all the connected inputs.  For example, if an <code>AudioChannelMerger</code>
      has two connected inputs (both stereo), then the output will be four channels, the first two from the first input and the
      second two from the second input.  In another example with two connected inputs (both mono), the output will be two channels (stereo),
      with the left channel coming from the first input and the right channel coming from the second input.
    </p>
    
    <p>
    Be aware that it is possible to connect an <code>AudioChannelMerger</code> in such a way that it outputs an audio stream with a large number of channels greater
    than the maximum supported by the system (currently 6 channels for 5.1).  In this case, if the output is connected to anything else then an exception will
    be thrown indicating an error condition.  Thus, the <code>AudioChannelMerger</code> should be used in situations where the numbers of input channels is well
    understood.
    </p>
    
    <pre>
    numberOfInputs == 6  // number of connected inputs may be less than this
    numberOfOutputs == 1
    </pre>
    
    <div class="block"><div class="blockTitleDiv"><span class="blockTitle">IDL</span></div><div class="blockContent"><pre class="code"><code class="idl-code"> 

    interface <dfn id="dfn-AudioChannelMerger">AudioChannelMerger</dfn> : AudioNode {

    };
    </code></pre></div></div>

  </div> 











    <div id="AudioElementIntegration-section" class="section"> 
    <h2>21. Integration with the <code>audio</code> and <code>video</code> elements</h2> 

  <p>
  It requires some thought to integrate cleanly with the existing media elements because they do not seem to have been designed with the idea of multiple
  types of audio sources, and its API is currently heavily oriented toward streaming.
  </p>



  <h3>Approach 1:</h3>


  One approach is to add a new attribute to the media elements <code>audio</code> and <code>video</code>, which for now can be called <code>audioSource</code>.
  It would be an <a href="#AudioNode-section"><code>AudioNode</code></a> of type <a href="#MediaElementAudioSourceNode"><code>MediaElementAudioSourceNode</code></a> which could be directly wired into an audio routing graph for processing streaming audio.

  The other types of AudioSourceNodes would be able to operate independently from any <code>audio</code> or <code>video</code> element:

<ul>
  <li>AudioBufferSourceNode</li>
  <li>JavaScriptSourceNode</li>
  <li>AudioInputSourceNode:
   a hypothetical source node allowing device access to live audio input (microphone, etc.) not described in this document.
  </li>
</ul>
  The API for HTMLMediaElement (which is used by the <code>audio</code> element) seems to be very heavily oriented around network, streaming/buffering,
   and error states which are not at all applicable to these other source node types.

  <h3>Approach 2:</h3>

  Here it can be considered that an AudioSourceNode exists only when used with a corresponding <code>audio</code> element.
  As in the first approach, the <code>audio</code> element's new audioSource attribute would be used to access the
   <a href="#AudioSourceNode-section"><code>AudioSourceNode</code></a>.
  This would require adding new constructors to Audio for each of the different cases:
  
  <pre>

  audio = new Audio( [ url ] )
  audio = new Audio( [ AudioBuffer ] )
  audio = new Audio( [ AudioCallback ] ) // AudioCallback for direct JavaScript synthesis
  audio = new Audio( [ AudioInput ] )    // AudioInput for audio input device access
  
  </pre>

  This has the problem that none of the <code>audio</code> API seems to be relevant or even clearly workable with the callback and external audio input case.
  It seems a clumsy fit at best.

  </div>


  <div id="MixerGainStructure-section" class="section"> 
  <h2>22. Mixer Gain Structure</h2> 

  <h3> Background</h3>
  <p>
  One of the most important considerations when dealing with audio processing graphs is how to adjust the gain (volume) at various points.  For example, in a standard mixing board model,
  each input bus has pre-gain, post-gain, and send-gains.  Submix and master out busses also have gain control.  The gain control described here can be used to implement
  standard mixing boards as well as other architectures.
  </p>

  <div id="SummingJunction-section" class="section">
  <h3> Summing Inputs</h3>
  </div>
  
  <p>
  The inputs to <a href="#AudioNode-section"><code>AudioNodes</code></a> have the ability to accept connections from multiple outputs.
  The input then acts as a unity gain summing junction with each output signal being added with the others:
  </p>

  <img src="unity-gain-summing-junction.png"/>

<p>
  In cases where the channel layouts of the outputs do not match, an <a href="#UpMix-section">up-mix</a> will occur to the highest number of channels.
</p>

  <h3> Gain Control</h3>
  <p>
  But many times, it's important to be able to control the gain for each of the output signals.  The <a href="#AudioGainNode-section"><code>AudioGainNode</code></a> gives this control:
  </p>

  <img src="mixer-architecture-new.png"/>
  
  <p>
  Using these two concepts of unity gain summing junctions and AudioGainNodes, it's possible to construct simple or complex mixing scenarios.
  </p>
  
  <h3> Example: Mixer with Send Busses</h3>
  
  <p>
  In a routing scenario involving multiple sends and submixes, explicit control is needed over the volume or "gain" of each connection to a mixer.
  Such routing topologies are very common and exist in even the simplest of electronic gear sitting around in a basic recording studio.
  </p>

  <p>
  Here's an example with two send mixers and a main mixer.  Although possible, for simplicity's sake, pre-gain control and insert effects are not illustrated:
  </p>
  
  <img src="mixer-gain-structure.png"/>
  
  <p>
    This diagram is using a shorthand notation where "send 1", "send 2", and "main bus" are actually inputs to AudioNodes, but here are represented as summing busses,
    where the intersections g2_1, g3_1, etc. represent the "gain" or volume for the given source on the given mixer.
    In order to expose this gain, an <a href="#dfn-AudioGainNode"> <code>AudioGainNode</code></a> is used:
  </p>
  
  <p>
  Here's how the above diagram could be constructed in JavaScript:
  </p>
 
  <div class="example"><div class="exampleHeader">Example</div> 
 
          <div class="block"><div class="blockTitleDiv"><span class="blockTitle">ECMAScript</span></div><div class="blockContent"><pre class="code"><code class="es-code"> 

var context = 0;
var compressor = 0;
var reverb = 0;
var chorus = 0;
var s1 = 0;
var s2 = 0;

var source1 = 0;
var source2 = 0;
var g1_1 = 0;
var g2_1 = 0;
var g3_1 = 0;
var g1_2 = 0;
var g2_2 = 0;
var g3_2 = 0;

<span class="comment">// Setup routing graph </span>
function setupRoutingGraph() {
    context = new AudioContext();

    compressor = context.createCompressor();

    <span class="comment">// Send1 effect </span>
    reverb = context.createConvolver();
    <span class="comment">// Convolver impulse response may be set here or later </span>

    <span class="comment">// Send2 effect </span>
    chorus = context.createChorus();

    <span class="comment">// Connect final compressor to final destination </span>
    compressor.connect(context.destination);

    <span class="comment">// Connect sends 1 & 2 through effects to main mixer </span>
    s1 = context.createGainNode();
    reverb.connect(s1);
    s1.connect(compressor);
    
    s2 = context.createGainNode();
    chorus.connect(s2);
    s2.connect(compressor);

    <span class="comment">// Create a couple of sources </span>
    source1 = context.createBufferSource();
    source2 = context.createBufferSource();
    source1.buffer = manTalkingBuffer;
    source2.buffer = footstepsBuffer;

    <span class="comment">// Connect source1 </span>
    g1_1 = context.createGainNode();
    g2_1 = context.createGainNode();
    g3_1 = context.createGainNode();
    source1.connect(g1_1);
    source1.connect(g2_1);
    source1.connect(g3_1);
    g1_1.connect(compressor);
    g2_1.connect(reverb);
    g3_1.connect(chorus);

    <span class="comment">// Connect source2 </span>
    g1_2 = context.createGainNode();
    g2_2 = context.createGainNode();
    g3_2 = context.createGainNode();
    source2.connect(g1_2);
    source2.connect(g2_2);
    source2.connect(g3_2);
    g1_2.connect(compressor);
    g2_2.connect(reverb);
    g3_2.connect(chorus);

    <span class="comment">// We now have explicit control over all the volumes g1_1, g2_1, ..., s1, s2 </span>
    g2_1.gain.value = 0.2; <span class="comment"> // For example, set source1 reverb gain </span>

    <span class="comment"> // Because g2_1.gain is of type "AudioGain" which is an "AudioParam", </span>
    <span class="comment"> // an automation curve could also be attached to it. </span>
    <span class="comment"> // A "mixing board" UI could be created in canvas or WebGL controlling these gains. </span>
}

 </code></pre></div></div> 
  
  
  </div>


  <br><br>
  <div id="ChannelLayouts-section" class="section"> 
  <h2>23. Channel Layouts</h2>

  <p>
  It's important to define the channel ordering (and define some abbreviations) for different layouts. 
  A simple implementation could consider only handling mono and stereo audio sources.
  </p>

  <p>
    The channel layouts are clear:
  </p>

  <pre>
  Mono
    0: M: mono
    
  Stereo
    0: L: left
    1: R: right
  </pre>
  
  <p>
  A more advanced implementation can handle channel layouts for quad and 5.1:
  </p>

  <pre>
  Quad
    0: L:  left
    1: R:  right
    2: SL: surround left
    3: SR: surround right

  5.1
    0: L:   left
    1: R:   right
    2: C:   center
    3: LFE: subwoofer
    4: SL:  surround left
    5: SR:  surround right
  </pre>

  <p>
  Other layouts can also be considered.
  </p>

  <div id="UpMix-section" class="section"> 
  <h2>24. Channel up-mixing and down-mixing</h2>
  
  For now, only considers cases for mono, stereo, quad, 5.1.  Later other channel layouts can be defined.
  <h3>Up Mixing</h3>
  <p>
  Consider what happens when converting an audio stream with a lower number of channels to one with a higher number of channels.
  This can be necessary when <a href="#SummingJunction-section">mixing several outputs together</a> where the channel layouts differ.  It can also be necessary if the rendered audio
  stream is played back on a system with more channels.
  </p>
  
<pre>
Mono up-mix:
    
    1 -> 2 : equal-power up-mix from mono to stereo
        output.L = 0.707 * input;
        output.R = 0.707 * input;

    1 -> 4 : equal-power up-mix from mono to quad
        output.L = 0.707 * input;
        output.R = 0.707 * input;
        output.SL = 0;
        output.SR = 0;

    1 -> 5.1 : up-mix from mono to 5.1
        output.L = 0;
        output.R = 0;
        output.C = input; // put in center channel
        output.LFE = 0;
        output.SL = 0;
        output.SR = 0;

Stereo up-mix:

    2 -> 4 : up-mix from stereo to quad
        output.L = input.L;
        output.R = input.R;
        output.SL = 0;
        output.SR = 0;

    2 -> 5.1 : up-mix from stereo to 5.1
        output.L = input.L;
        output.R = input.R;
        output.C = 0;
        output.LFE = 0;
        output.SL = 0;
        output.SR = 0;

Quad up-mix:

    4 -> 5.1 : up-mix from stereo to 5.1
        output.L = input.L;
        output.R = input.R;
        output.C = 0;
        output.LFE = 0;
        output.SL = input.SL;
        output.SR = input.SR;

</pre>

  <h3>Down Mixing</h3>
  <p>
  A down-mix will be necessary, for example, if processing 5.1 source material, but playing back stereo.
  </p>
  
  <pre>
  
Mono down-mix:

    2 -> 1 : stereo to mono
        output = 0.5 * (input.L + input.R);

    4 -> 1 : quad to mono
        output = 0.25 * (input.L + input.R + input.SL + input.SR);

    5.1 -> 1 : 5.1 to mono
        ???


Stereo down-mix:

    4 -> 2 : quad to stereo
        output.L = 0.5 * (input.L + input.SL);
        output.R = 0.5 * (input.R + input.SR);

    5.1 -> 2 : 5.1 to stereo
        ???

</pre>






  </div>

  <div id="EventScheduling-section" class="section"> 
  <h2>25. Event Scheduling</h2> 
    Need more detail here, but for now:
    <ul>
  	<li> Audio events such as start/stop play and volume fades can be scheduled
  		to happen in a rhythmically perfect way (sample-accurate scheduling)
  	<li> Allows sequencing applications such as drum-machines, digital-dj mixers.  Ultimately, it may be useful for DAW applications.
  	<li> Allows rhythmically accurate segueways from one section of music to
  		another (as is possible with the FMOD engine)
  	<li> Allows scheduling of sound "grains" for granular synthesis effects.
    </ul>

    </div>







<div id="Spatialization-section" class="section"> 
<h2>26. Spatialization / Panning </h2>

<h3> Background</h3>

<p>
A common feature requirement for modern 3D games is the ability to dynamically spatialize and move multiple audio sources in 3D space.
</p>

<p>
Using an <code>AudioPannerNode</code>, an audio stream can be spatialized or positioned in space relative to an <code>AudioListener</code>.  An <a href="#AudioContext-section"><code>AudioContext</code></a> will
contain a single <code>AudioListener</code>.   Both panners and listeners have a position in 3D space using a cartesian coordinate system.
<code>AudioPannerNode</code> objects (representing the source stream) have an <code>orientation</code> vector representing in which direction the sound is projecting.
Additionally, they have a <code>sound cone</code> representing how directional the sound is.  For example, the sound could be omnidirectional, in which case it would be heard
anywhere regardless of its orientation, or it can be more directional and heard only if it is facing the listener.
<code>AudioListener</code> objects (representing a person's ears) have an <code>orientation</code> and <code>up</code> vector representing in which direction the person is facing.
Because both the source stream and the listener can be moving, they both have a <code>velocity</code> vector representing both the speed and direction of movement.  Taken together,
these two velocities can be used to generate a doppler shift effect which changes the pitch.
</p>

<h3>Panning Algorithm</h3>

<p>
The following algorithms can be implemented:
</p>

<ul>
  
  <li> Equal-power (Vector-based) panning
    <p>
      This is a simple and relatively inexpensive algorithm which provides basic, but reasonable results.
    </p>

    <br>
    
    <li> Sound-field (<a href="http://www.ambisonic.net/">Ambisonics</a>)
      <p>
        Attempts to recreate the acoustic field.
      </p>

  <br>
<li> <a href="http://en.wikipedia.org/wiki/Head-related_transfer_function">HRTF</a> panning (stereo only)
  <p>
    This requires a set of HRTF impulse responses recorded at a variety of azimuths and elevations.  There are a small number of open/free impulse responses available.  The implementation requires a highly optimized convolution function.  It is somewhat more costly than "equal-power", but provides a more spatialized sound.
  </p>
  <img src="HRTF_panner.png">

  <li> Pass-through
    <p>
      This is mostly useful for stereo sources to pass the left/right channels unpanned to the left/right speakers.  Similarly for 5.0 sources,
      the channels can be passed unchanged.
    </p>

    <li> Matrix Mix
      <p>
        This is a lower-level approach to panning a source, and would ignore the source/listener positions.  Instead, an M x N "gain matrix" is used to explicitly set
        the mix levels from an N channel source to a M channel output.  This would be an advanced feature, not necessary in an initial implementation.
      </p>
</ul>


<h3> Distance Effects</h3>
<ul>
<li>Sources farther away are typically quieter than nearer ones.
<li>Different rolloff curves are assignable per-source: linear, inverse, exponential
</ul

<h3> Sound Cones</h3>

<p>
The listener and each sound source have an orientation vector describing which way they are facing.
Each sound source's sound projection characteristics are described by an inner and outer "cone" describing the
sound intensity as a function of the source/listener angle from the source's orientation vector.   Thus, a sound source
pointing directly at the listener will be louder than if it is pointed off-axis. Sound sources can also be omni-directional.
</p>



<p>
<h3> Doppler Shift</h3>
  <ul>
	<li> Introduces a pitch shift which can realistically simulate moving
		sources
	<li> Depends on: source / listener velocity vectors, speed of sound, doppler factor
  </ul>


</div







<div id="Convolution-section" class="section"> 
<h2>27. Linear Effects using Convolution</h2>

<h3>Background</h3>
<p>
<a href="http://en.wikipedia.org/wiki/Convolution">Convolution</a> is a mathematical process which can be applied to an audio signal to achieve many interesting high-quality linear effects.
Very often, the effect is used to simulate an acoustic space such as a concert hall, cathedral, or outdoor amphitheater.  It can also
be used for complex filter effects, like a muffled sound coming from inside a closet, sound underwater, sound coming through a telephone,
or playing through a vintage speaker cabinet.  This technique is very commonly used in major motion picture and music production and is
considered to be extremely versatile and of high quality.
</p>

<p>
Each unique effect is defined by an <code>impulse response</code>.  An impulse response can be represented as an audio file and <a href="#recording-impulse-responses">can be recorded</a> from 
a real acoustic space such as a cave, or can be synthetically generated through a great variety of techniques.
</p>

<h3>Motivation for use as a Standard</h3>
<p>
A key feature of many game audio engines (OpenAL, FMOD, Creative's EAX, Microsoft's XACT Audio, etc.) is a reverberation effect for simulating the sound of being in an acoustic space.
But the code used to generate the effect has generally been custom and algorithmic (generally using
a hand-tweaked set of delay lines and allpass filters which feedback into each other).  In nearly all cases, not only is the implementation custom, but
the code is proprietary and closed-source, each company adding its own "black magic" to achieve its unique quality.
Each implementation being custom with a different set of parameters makes it impossible to achieve a uniform desired effect.  And the code
being proprietary makes it impossible to adopt a single one of the implementations as a standard.  Additionally, algorithmic reverberation effects
are limited to a relatively narrow range of different effects, regardless of how the parameters are tweaked.
</p>

<p>
A convolution effect solves these problems by using a very precisely defined mathematical algorithm as the basis of its processing.
An impulse response represents an exact sound effect to be applied to an audio stream and
is easily represented by an audio file which can be referenced by URL.  The range of possible effects is enormous.
</p>



<h3>Reverb Effect (with matrixing)</h3>

<p>
Single channel convolution operates on a mono audio source, using a mono impulse response.  But to achieve a more spacious sound,
multi-channel audio sources and impulse responses must be considered.  Audio sources and playback systems can be stereo, 5.1, or more
channels.  In the general case the source has N input channels, the impulse response has K channels, and the playback system has M output channels.
Thus it's a matter of how to matrix these channels to achieve the final result.  The following diagram, illustrates the common cases for stereo
playback where N, K, and M are all less than or equal to 2.  Similarly, the matrixing for 5.1 and other playback configurations can be defined.
</p>

<img src="reverb-matrixing.png">


<a name="recording-impulse-responses">
<h3>Recording Impulse Responses</h3>
</a>

<img src="impulse-response.png">
<br><br>

The most <a href="http://pcfarina.eng.unipr.it/Public/Papers/226-AES122.pdf">modern</a>
 and accurate way to record the impulse response of a real acoustic space is to use
a long exponential sine sweep.  The test-tone can be as long as 20 or 30 seconds, or longer.




  Several recordings of the
test tone played through a speaker can be made with microphones placed and oriented at various positions in the room.  It's important
to document speaker placement/orientation, the types of microphones, their settings, placement, and orientations for each recording taken.

<p>
Post-processing is required for each of these recordings by performing an inverse-convolution with the test tone,
yielding the impulse response of the room with the corresponding microphone placement.  These impulse responses are then
ready to be loaded into the convolution reverb engine to re-create the sound of being in the room.
</p>

<h3>Tools</h3>
Two command-line tools have been written:
</p>
 <code>generate_testtones</code> generates an exponential sine-sweep test-tone and its inverse.  Another
tool <code>convolve</code> was written for post-processing.  With these tools, anybody with recording equipment can record their own impulse responses.
  To test the tools in practice, several recordings were made in a warehouse space with interesting
acoustics.  These were later post-processed with the command-line tools.
</p>

<pre>

% generate_testtones -h
Usage: generate_testtone
	[-o /Path/To/File/To/Create] Two files will be created: .tone and .inverse
	[-rate <sample rate>] sample rate of the generated test tones
	[-duration <duration>] The duration, in seconds, of the generated files
	[-min_freq <min_freq>] The minimum frequency, in hertz, for the sine sweep

% convolve -h
Usage: convolve input_file impulse_response_file output_file
    </pre>
    
    
    
    
<br>


<h3>Recording Setup</h3>
<img src="recording-setup.png">
<br><br>

Audio Interface: Metric Halo Mobile I/O 2882 

<br><br><br><br>


<img src="microphones-speaker.png">
<br><br>

<img src="microphone.png">
<img src="speaker.png">
<br><br>
Microphones: AKG 414s, Speaker: Mackie HR824

<br><br><br>

<h3>The Warehouse Space</h3>

<img src="warehouse.png">
<br><br>

</div>



<div id="JavaScriptProcessing-section" class="section"> 
<h2>28. JavaScript Synthesis and Processing</h2>

<p>
The Mozilla project has conducted <a href="https://wiki.mozilla.org/Audio_Data_API">Experiments</a> to synthesize and process audio directly in JavaScript.
This approach is interesting for a certain class of audio processing and they have produced a number of impressive demos.  This specification includes
a means of synthesizing and processing directly using JavaScript by using special types of <a href="#AudioNode-section"><code>AudioNode</code></a> objects.
</p>

<p>
JavaScript has a variety of <a href="#Performance-section">performance issues</a> so it is not suitable for all types of audio processing.
The approach proposed in this document includes the ability to perform computationally intensive aspects of the audio processing (too expensive for JavaScript to compute in real-time) 
such as multi-source 3D spatialization and convolution in optimized C++ code.  Both direct JavaScript processing and C++ optimized code can be combined due to the APIs
 <a href="#ModularRouting-section">modular approach</a>.
</p>






<div id="RealtimeAnalysis-section" class="section"> 
<h2>29. Realtime Analysis</h2>




</div>


<div id="Performance-section" class="section"> 
<h2>30. Performance Considerations</h2>

<h3>Latency: What it is and Why it's Important?</h3>

<img src="latency.png">

<p>
  This time delay is called latency and is caused by several factors (input device latency, internal buffering latency, DSP processing latency, output device latency, distance of user's ears from speakers, etc.), and is cummulative.  The larger this latency is, the less satisfying the user's experience is going
  to be.  In the extreme, it can make musical production or game-play impossible.  At moderate levels it can affect timing and give the impression of
  sounds lagging behind or the game being non-responsive.  For musical applications the timing problems affect rhythm.  For gaming, the timing problems affect precision of  gameplay.
  For interactive applications, it generally cheapens the users experience much in the same way that very low animation frame-rates do.
  Depending on the application, a reasonable latency can be from as low as 3-6 milliseconds to 25-50 milliseconds.
</p>


<div id="Glitching-section" class="section">
<h3>Audio Glitching:</h3>
</div>
<p>
  Audio glitches are caused by an interruption of the normal continuous audio stream, resulting in loud clicks and pops.  It is considered to be
  a catastrophic failure of a multi-media system and must be avoided.  It can be caused by problems with the threads responsible for delivering the audio
  stream to the hardware, such as scheduling latencies caused by threads not having the proper priority and time-constraints.  It can also be caused by
  the audio DSP trying to do more work than is possible in real-time given the CPU's speed.
</p>


<h3>Hardware Scalability:</h3>
<p>
The system should gracefully degrade to allow audio processing under resource constrained conditions without dropping audio frames.
</p>

<p>
First of all, it should be clear that regardless of the platform, the audio processing load should never be enough to completely lock up the 
machine.  Second, the audio rendering needs to produce a clean, un-interrupted audio stream without audible
<a href="#Glitching-section">glitches</a>.
</p>	

<p>
The system should be able to run on a range of hardware, from mobile phones and tablet devices to laptop and desktop computers.
But the more limited compute resources on a phone device make it necessary to consider techniques to scale back and reduce the complexity
of the audio rendering.  For example, voice-dropping algorithms can be implemented to reduce the total number of notes playing at any given time.
</p>
	



<p>
Here's a list of some techniques which can be used to limit CPU usage:
</p>

<h4>CPU monitoring</h4>
<p>
In order to avoid audio breakup, CPU usage must remain below 100%.
</p>
<p>
The relative CPU usage can be dynamically measured for each AudioNode (and chains of connected nodes) as a percentage of the rendering time
quantum.  In a single-threaded implementation, overall CPU usage must remain below 100%.  The measured usage may be used internally in the implementation
for dynamic adjustments to the rendering.  It may also be exposed through a <code>cpuUsage</code> attribute of <code>AudioNode</code>
for use by JavaScript.
</p>

<p>
In cases where the measured CPU usage is near 100% (or whatever threshold is considered too high), then an attempt to add additional
<code>AudioNodes</code> into the rendering graph can trigger voice-dropping.
</p>

<h4>Voice Dropping</h4>
<p>
	Voice-dropping is a technique which limits the number of voices (notes) playing at the same time to keep CPU usage within a reasonable range.
	There can either be an upper threshold on the total number of voices allowed at any given time, or CPU usage can be dynamically monitored
	and voices dropped when CPU usage exceeds a threshold.  Or a combination of these two techniques can be applied.  When CPU usage is monitored
	for each voice, it can be measured all the way from the AudioSourceNode through any effect processing nodes which apply uniquely to that voice.
</p>

<p>	
  When a voice is "dropped", it
	needs to happen in such a way that it doesn't introduce audible clicks or pops into the rendered audio stream.  One way to achieve this is to
	quickly fade-out the rendered audio for that voice before completely removing it from the rendering graph.
</p>	

<p>	
	When it is determined that one or more voices must be dropped, there are various strategies for picking which voice(s) to drop out of the
	total ensemble of voices currently playing.  Here are some of the factors which can be used in combination to help with this decision:
</p>

<ul>
	<li> Older voices, which have been playing the longest can be dropped instead of more recent voices. </li>
	<li> Quieter voices, which are contributing less to the overall mix may be dropped instead of louder ones. </li>
	<li> Voices which are consuming relatively more CPU resources may be dropped instead of less "expensive" voices.
	<li> An AudioNode can have a <code>priority</code> attribute to help determine the relative importance of the voices.</li>
</ul>

<h4>Simplification of Effects Processing</h4>

<p>
Most of the effects described in this document are relatively inexpensive and will likely be able to run even on the slower mobile devices.
However, the <a href="#ConvolverNode-section">convolution effect</a> can be configured with a variety of impulse responses, some of which
will likely be too heavy for mobile devices.  Generally speaking, CPU usage scales with the length of the impulse response and the number of channels it has.  Thus, it is reasonable to consider that impulse responses which exceed a certain length will not be allowed to run.
The exact limit can be determined based on the speed of the device.  Instead of outright rejecting convolution with these long responses,
it may be interesting to consider truncating the impulse responses to the maximum allowed length and/or reducing the number of channels
of the impulse response.
</p>

<p>
In addition to the convolution effect.  The <a href="#AudioPannerNode-section"><code>AudioPannerNode</code></a> may also be expensive
if using the HRTF panning model.  For slower devices, a cheaper algorithm such as EQUALPOWER can be used to conserve compute resources.
</p>

<h4>Sample Rate</h4>
<p>
For very slow devices, it may be worth considering running the rendering at a lower sample-rate than normal.  For example, the sample-rate 
can be reduced from 44.1KHz to 22.05KHz.  This decision must be made when the <code>AudioContext</code> is created, because changing the sample-rate on-the-fly can be difficult
to implement and will result in audible glitching when the transition is made.
</p>



<h4>Preflighting</h4>
<p>
It should be possible to invoke some kind of "pre-flighting" code (through JavaScript) to roughly determine the power of the machine.
The JavaScript code can then use this information to scale back any more intensive processing it may normally run on a more powerful machine.
Also, the underlying implementation may be able to factor in this information in the voice-dropping algorithm.
</p>

<p>
	TODO: add specification and more detail here
</p>

<h4>Authoring for different user agents</h4>
JavaScript code can use information about user-agent to scale back any more intensive processing it may normally run on a more powerful machine.

<h4>Scalability of Direct JavaScript Synthesis / Processing</h4>
<p>
Any audio DSP / processing code done directly in JavaScript should also be concerned about scalability.  To the extent possible, the JavaScript
code itself needs to monitor CPU usage and scale back any more ambitious processing when run on less powerful devices.  If it's an "all or nothing" type of processing, then user-agent check or pre-flighting should be done to avoid generating an audio stream with audio breakup.
</p>


<h3> JavaScript Issues with real-time Processing and Synthesis: </h3>

While processing audio in JavaScript, it is extremely challenging to get reliable, glitch-free audio while achieving a reasonably low-latency,
especially under heavy processor load.

<ul>
    <li> JavaScript is very much slower than heavily optimized C++ code and is not able to take advantage of SSE optimizations and multi-threading which is
        critical for getting good performance on today's processors.  Optimized native code can be on the order of twenty times faster for processing FFTs as
        compared with JavaScript.  It is not efficient enough for heavy-duty processing of audio such as convolution and 3D spatialization of large numbers of audio sources. </li>
    <li> setInterval() and XHR handling will steal time from the audio processing.  In a reasonably complex game, some JavaScript resources will be
      needed for game physics and graphics. This creates challenges because audio rendering is deadline driven (to avoid glitches and get low enough latency).</li>
    <li> JavaScript does not run in a real-time processing thread and thus can be pre-empted by many other threads running on the system.</li>
    <li> Garbage Collection (and autorelease pools on Mac OS X) can cause unpredictable delay on a JavaScript thread. </li>
    <li> Multiple JavaScript contexts can be running on the main thread, stealing time from the context doing the processing. </li>
    <li> Other code (other than JavaScript) such as page rendering runs on the main thread. </li>
    <li> Locks can be taken and memory is allocated on the JavaScript thread.  This can cause additional thread preemption. </li>
</ul>

The problems are even more difficult with today's generation of mobile devices which have processors with relatively poor performance and power consumption / battery-life issues.


<br>
<br>


<div id="ExampleApplications-section" class="section"> 
<h2>31. Example Applications</h2> 

<p>
Here are some of the types of applications a web audio system should be able to support.
  (the <a href="http://chromium.googlecode.com/svn/trunk/samples/audio/index.html">demo</a> page has more examples)
</p>


<h3>Beach Demo</h3>

<img src="beach-demo.png">

<br><br>
3D environments with audio are common in games made for desktop applications and game consoles.
Imagine a 3D island environment with spatialized audio, seagulls flying overhead, the waves crashing against the shore, the
crackling of the fire, the creaking of the bridge, and the rustling of the trees in the wind.  The sounds can be positioned
naturally as one moves through the scene.  Even going underwater, low-pass filters can be tweaked for just the right underwater sound.

  <br><br>

<h3>Game Physics</h3>

<img src="box-2d.png">

<br><br>
<a href="http://www.box2d.org/">Box2D</a> is an interesting open-source library for 2D game physics.  It has various implementations, including one
based on Canvas 2D.  Using a prototype implementation, dynamic sound effects have been added for each of the object collisions, taking into account the velocities vectors and
positions to spatialize the sound events, and modulate audio effect parameters such as filter cutoff.

<h3>Drum Machine</h3>

<img src="drum-machine.png">

<br><br>
Applications requiring tight scheduling of audio events can be implemented.  They can be both educational and entertaining. 
<br>
(please excuse the primitive looking UI)

<h3>Realtime Music Visualizer</h3>
<img src="visualizer2-gl.png">
<br><br>
When combined with WebGL GLSL shaders, realtime analysis data can be presented.  These can be as advanced as any found in iTunes.
<br><br>

<h3>Educational Applications</h3>
<p>
    ... more info ...
</p>
<br><br>

</div>






<div id="SecurityConsiderations-section" class="section"> 
<h2>32. Security Considerations</h2> 
<p> 
  This section is <em>informative.</em> 
</p> 
</div> 

<div id="requirements" class="section"> 
<h2>33. Requirements and Use Cases</h2> 
</div> 

<div id="ChangeLog-section" class="section"> 
<h2>34. Change Log</h2> 

<pre>
------------------------------------------------------------------------
v1.0.17 | crogers@google.com | 2010-07-28 16:26:56 -0700 (Wed, 28 Jul 2010) | 1 line

add DelayNode, AudioChannelSplitter, and AudioChannelMerger

------------------------------------------------------------------------
v1.0.16 | crogers@google.com | 2010-07-26 11:46:33 -0700 (Mon, 26 Jul 2010) | 1 line

added lots more detail to Hardware Scalability section

------------------------------------------------------------------------
v1.0.15 | crogers@google.com | 2010-07-20 12:37:00 -0700 (Tue, 20 Jul 2010)

minor fix to Down Mixing section

------------------------------------------------------------------------
v1.0.14 | crogers@google.com | 2010-07-20 12:21:31 -0700 (Tue, 20 Jul 2010)

* added change history section
* added many more links from JavaScript class names (AudioContext, AudioNode, etc.) to their description section
* added documentation for more classes:
    AudioSourceNode
    AudioDestinationNode
* changed name of AudioElementSourceNode to MediaElementAudioSourceNode and refined description
* tried to better organize order of classes
* moved AudioDelayNode to more important status
* added Channel Layouts section
* added Channel up-mixing and down-mixing section, and added links to this section
* changed name of AudioContext's createGain() method to createGainNode()
* removed sampleRate attribute from AudioNode - now AudioContext sampleRate determines everything
* added comment about AudioContext (basic implementation allows only one per document)
* removed some old obsolete references to "ownership"
* added (numberOfInputs == x : numberOfOutputs == y) to all AudioNode subclasses

------------------------------------------------------------------------
v1.0.13 | crogers@google.com | 2010-06-25 16:17:12 -0700 (Fri, 25 Jun 2010)

change to new type names: WebGLFloatArray -> Float32Array
------------------------------------------------------------------------
v1.0.12 | crogers@google.com | 2010-06-23 12:39:45 -0700 (Wed, 23 Jun 2010)

organize "Mixer Gain Structure" section better
------------------------------------------------------------------------
v1.0.11 | crogers@google.com | 2010-06-23 12:14:56 -0700 (Wed, 23 Jun 2010)

fix typo
------------------------------------------------------------------------
v1.0.10 | crogers@google.com | 2010-06-23 12:13:01 -0700 (Wed, 23 Jun 2010)

Some style tweaks to the language:
* Use third person.  Avoid I, we, you
* try to avoid ... and , etc.
* other miscellaneous language cleanup: javascript -> JavaScript
* added audio incubator list email address

------------------------------------------------------------------------
v1.0.9 | crogers@google.com | 2010-06-23 11:19:28 -0700 (Wed, 23 Jun 2010)

small language change: use "can" instead of "may"
------------------------------------------------------------------------
v1.0.8 | crogers@google.com | 2010-06-22 18:52:02 -0700 (Tue, 22 Jun 2010)

add getChannelData() method to AudioBuffer
------------------------------------------------------------------------
v1.0.7 | crogers@google.com | 2010-06-22 18:36:22 -0700 (Tue, 22 Jun 2010)

Lots of changes:
* Get rid of AudioMixerNode and AudioMixerInputNode, replacing with AudioGainNode and unity gain summing junctions for inputs
* Get rid of "owner"
* Change AudioListener to be attribute of AudioContext, no longer need to set listener for AudioPannerNode
* Change name of AudioOutputNode to AudioDestinationNode (to be symmetric with AudioSourceNode)
* added createBuffer() to AudioContext

------------------------------------------------------------------------
v1.0.6 | crogers@google.com | 2010-06-14 15:01:46 -0700 (Mon, 14 Jun 2010)

tweaks to performance section
------------------------------------------------------------------------
v1.0.5 | crogers@google.com | 2010-06-09 17:48:27 -0700 (Wed, 09 Jun 2010)

small wording change
------------------------------------------------------------------------
v1.0.4 | crogers@google.com | 2010-06-09 13:03:22 -0700 (Wed, 09 Jun 2010)

add a single simple javascript example - Chris Marrin's suggestion
------------------------------------------------------------------------
v1.0.3 | crogers@google.com | 2010-06-09 12:36:43 -0700 (Wed, 09 Jun 2010)

address Andrew Scherkus's comments
------------------------------------------------------------------------
v1.0.2 | crogers@google.com | 2010-06-02 13:26:35 -0700 (Wed, 02 Jun 2010)

address first of Eric Carlson's comments
------------------------------------------------------------------------
v1.0.1 | crogers@google.com | 2010-06-01 15:46:35 -0700 (Tue, 01 Jun 2010)

change mime types
------------------------------------------------------------------------
v1.0.0 | crogers@google.com | 2010-06-01 15:42:23 -0700 (Tue, 01 Jun 2010)

add specification files
------------------------------------------------------------------------


</pre>

</div> 

  
  
  
  
  
    </div> 
   
    </div> 
  </body> 
</html>